diff --git a/dom/svg/SVGPathSegListSMILType.cpp b/dom/svg/SVGPathSegListSMILType.cpp
--- a/dom/svg/SVGPathSegListSMILType.cpp
+++ b/dom/svg/SVGPathSegListSMILType.cpp
@@ -228,17 +228,17 @@ AddWeightedPathSegs(double aCoeff1,
  * @param aCoeff1    The coefficient to use on the first path segment list.
  * @param aList1     The first path segment list. Allowed to be identity.
  * @param aCoeff2    The coefficient to use on the second path segment list.
  * @param aList2     The second path segment list.
  * @param [out] aResultSeg The resulting path segment list. Allowed to be
  *                         identity, in which case we'll grow it to the right
  *                         size. Also allowed to be the same list as aList1.
  */
-static void
+static nsresult
 AddWeightedPathSegLists(double aCoeff1, const SVGPathDataAndInfo& aList1,
                         double aCoeff2, const SVGPathDataAndInfo& aList2,
                         SVGPathDataAndInfo& aResult)
 {
   MOZ_ASSERT(aCoeff1 >= 0.0 && aCoeff2 >= 0.0,
              "expecting non-negative coefficients");
   MOZ_ASSERT(!aList2.IsIdentity(),
              "expecting 2nd list to be non-identity");
@@ -259,33 +259,35 @@ AddWeightedPathSegLists(double aCoeff1, 
   SVGPathDataAndInfo::const_iterator iter2 = aList2.begin();
   SVGPathDataAndInfo::const_iterator end2 = aList2.end();
 
   // Grow |aResult| if necessary. (NOTE: It's possible that aResult and aList1
   // are the same list, so this may implicitly resize aList1. That's fine,
   // because in that case, we will have already set iter1 to nullptr above, to
   // record that our first operand is an identity value.)
   if (aResult.IsIdentity()) {
-    DebugOnly<bool> success = aResult.SetLength(aList2.Length());
-    MOZ_ASSERT(success, "infallible nsTArray::SetLength should succeed");
+    if (!aResult.SetLength(aList2.Length())) {
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
     aResult.SetElement(aList2.Element()); // propagate target element info!
   }
 
   SVGPathDataAndInfo::iterator resultIter = aResult.begin();
 
   while ((!iter1 || iter1 != end1) &&
          iter2 != end2) {
     AddWeightedPathSegs(aCoeff1, iter1,
                         aCoeff2, iter2,
                         resultIter);
   }
   MOZ_ASSERT((!iter1 || iter1 == end1) &&
              iter2 == end2 &&
              resultIter == aResult.end(),
              "Very, very bad - path data corrupt");
+  return NS_OK;
 }
 
 static void
 ConvertPathSegmentData(SVGPathDataAndInfo::const_iterator& aStart,
                        SVGPathDataAndInfo::const_iterator& aEnd,
                        SVGPathDataAndInfo::iterator& aResult,
                        SVGPathTraversalState& aState)
 {
@@ -425,19 +427,17 @@ SVGPathSegListSMILType::Add(nsSMILValue&
     if (check == eRequiresConversion) {
       // Convert dest, in-place, to match the types in valueToAdd:
       ConvertAllPathSegmentData(dest.begin(), dest.end(),
                                 valueToAdd.begin(), valueToAdd.end(),
                                 dest.begin());
     }
   }
 
-  AddWeightedPathSegLists(1.0, dest, aCount, valueToAdd, dest);
-
-  return NS_OK;
+  return AddWeightedPathSegLists(1.0, dest, aCount, valueToAdd, dest);
 }
 
 nsresult
 SVGPathSegListSMILType::ComputeDistance(const nsSMILValue& aFrom,
                                         const nsSMILValue& aTo,
                                         double& aDistance) const
 {
   NS_PRECONDITION(aFrom.mType == this, "Unexpected SMIL type");
@@ -478,25 +478,24 @@ SVGPathSegListSMILType::Interpolate(cons
     // with incompatible segment types.
     return NS_ERROR_FAILURE;
   }
 
   const SVGPathDataAndInfo* startListToUse = &start;
   if (check == eRequiresConversion) {
     // Can't convert |start| in-place, since it's const. Instead, we copy it
     // into |result|, converting the types as we go, and use that as our start.
-    DebugOnly<bool> success = result.SetLength(end.Length());
-    MOZ_ASSERT(success, "infallible nsTArray::SetLength should succeed");
+    if (!result.SetLength(end.Length())) {
+      return NS_ERROR_OUT_OF_MEMORY;
+    }
     result.SetElement(end.Element()); // propagate target element info!
 
     ConvertAllPathSegmentData(start.begin(), start.end(),
                               end.begin(), end.end(),
                               result.begin());
     startListToUse = &result;
   }
 
-  AddWeightedPathSegLists(1.0 - aUnitDistance, *startListToUse,
-                          aUnitDistance, end, result);
-
-  return NS_OK;
+  return AddWeightedPathSegLists(1.0 - aUnitDistance, *startListToUse,
+                                 aUnitDistance, end, result);
 }
 
 } // namespace mozilla
