diff --git a/parser/htmlparser/nsScanner.cpp b/parser/htmlparser/nsScanner.cpp
--- a/parser/htmlparser/nsScanner.cpp
+++ b/parser/htmlparser/nsScanner.cpp
@@ -390,700 +390,16 @@ nsresult nsScanner::Peek(nsAString& aStr
 
   if (!CopyUnicodeTo(start, end, aStr)) {
     return NS_ERROR_OUT_OF_MEMORY;
   }
 
   return NS_OK;
 }
 
-
-/**
- *  Skip whitespace on scanner input stream
- *  
- *  @update  gess 3/25/98
- *  @param   
- *  @return  error status
- */
-nsresult nsScanner::SkipWhitespace(int32_t& aNewlinesSkipped) {
-
-  if (!mSlidingBuffer) {
-    return kEOF;
-  }
-
-  char16_t theChar = 0;
-  nsresult  result = Peek(theChar);
-  
-  if (NS_FAILED(result)) {
-    return result;
-  }
-  
-  nsScannerIterator current = mCurrentPosition;
-  bool      done = false;
-  bool      skipped = false;
-  
-  while (!done && current != mEndPosition) {
-    switch(theChar) {
-      case '\n':
-      case '\r': ++aNewlinesSkipped;
-      case ' ' :
-      case '\t':
-        {
-          skipped = true;
-          char16_t thePrevChar = theChar;
-          theChar = (++current != mEndPosition) ? *current : '\0';
-          if ((thePrevChar == '\r' && theChar == '\n') ||
-              (thePrevChar == '\n' && theChar == '\r')) {
-            theChar = (++current != mEndPosition) ? *current : '\0'; // CRLF == LFCR => LF
-          }
-        }
-        break;
-      default:
-        done = true;
-        break;
-    }
-  }
-
-  if (skipped) {
-    SetPosition(current);
-    if (current == mEndPosition) {
-      result = kEOF;
-    }
-  }
-
-  return result;
-}
-
-/**
- *  Skip over chars as long as they equal given char
- *  
- *  @update  gess 3/25/98
- *  @param   
- *  @return  error code
- */
-nsresult nsScanner::SkipOver(char16_t aSkipChar){
-
-  if (!mSlidingBuffer) {
-    return kEOF;
-  }
-
-  char16_t ch=0;
-  nsresult   result=NS_OK;
-
-  while(NS_OK==result) {
-    result=Peek(ch);
-    if(NS_OK == result) {
-      if(ch!=aSkipChar) {
-        break;
-      }
-      GetChar(ch);
-    } 
-    else break;
-  } //while
-  return result;
-
-}
-
-#if 0
-void DoErrTest(nsString& aString) {
-  int32_t pos=aString.FindChar(0);
-  if(kNotFound<pos) {
-    if(aString.Length()-1!=pos) {
-    }
-  }
-}
-
-void DoErrTest(nsCString& aString) {
-  int32_t pos=aString.FindChar(0);
-  if(kNotFound<pos) {
-    if(aString.Length()-1!=pos) {
-    }
-  }
-}
-#endif
-
-/**
- *  Consume characters until you run into space, a '<', a '>', or a '/'.
- *  
- *  @param   aString - receives new data from stream
- *  @return  error code
- */
-nsresult nsScanner::ReadTagIdentifier(nsScannerSharedSubstring& aString) {
-
-  if (!mSlidingBuffer) {
-    return kEOF;
-  }
-
-  char16_t         theChar=0;
-  nsresult          result=Peek(theChar);
-  nsScannerIterator current, end;
-  bool              found=false;  
-  
-  current = mCurrentPosition;
-  end = mEndPosition;
-
-  // Loop until we find an illegal character. Everything is then appended
-  // later.
-  while(current != end && !found) {
-    theChar=*current;
-
-    switch(theChar) {
-      case '\n':
-      case '\r':
-      case ' ' :
-      case '\t':
-      case '\v':
-      case '\f':
-      case '<':
-      case '>':
-      case '/':
-        found = true;
-        break;
-
-      case '\0':
-        ReplaceCharacter(current, sInvalid);
-        break;
-
-      default:
-        break;
-    }
-
-    if (!found) {
-      ++current;
-    }
-  }
-
-  // Don't bother appending nothing.
-  if (current != mCurrentPosition) {
-    if (!AppendUnicodeTo(mCurrentPosition, current, aString)) {
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
-  }
-
-  SetPosition(current);  
-  if (current == end) {
-    result = kEOF;
-  }
-
-  //DoErrTest(aString);
-
-  return result;
-}
-
-/**
- *  Consume characters until you run into a char that's not valid in an
- *  entity name
- *  
- *  @param   aString - receives new data from stream
- *  @return  error code
- */
-nsresult nsScanner::ReadEntityIdentifier(nsString& aString) {
-
-  if (!mSlidingBuffer) {
-    return kEOF;
-  }
-
-  char16_t         theChar=0;
-  nsresult          result=Peek(theChar);
-  nsScannerIterator origin, current, end;
-  bool              found=false;  
-
-  origin = mCurrentPosition;
-  current = mCurrentPosition;
-  end = mEndPosition;
-
-  while(current != end) {
- 
-    theChar=*current;
-    if(theChar) {
-      found=false;
-      switch(theChar) {
-        case '_':
-        case '-':
-        case '.':
-          // Don't allow ':' in entity names.  See bug 23791
-          found = true;
-          break;
-        default:
-          found = ('a'<=theChar && theChar<='z') ||
-                  ('A'<=theChar && theChar<='Z') ||
-                  ('0'<=theChar && theChar<='9');
-          break;
-      }
-
-      if(!found) {
-        if (!AppendUnicodeTo(mCurrentPosition, current, aString)) {
-          return NS_ERROR_OUT_OF_MEMORY;
-        }
-        break;
-      }
-    }
-    ++current;
-  }
-  
-  SetPosition(current);
-  if (current == end) {
-    if (!AppendUnicodeTo(origin, current, aString)) {
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
-    return kEOF;
-  }
-
-  //DoErrTest(aString);
-
-  return result;
-}
-
-/**
- *  Consume digits 
- *  
- *  @param   aString - should contain digits
- *  @return  error code
- */
-nsresult nsScanner::ReadNumber(nsString& aString,int32_t aBase) {
-
-  if (!mSlidingBuffer) {
-    return kEOF;
-  }
-
-  NS_ASSERTION(aBase == 10 || aBase == 16,"base value not supported");
-
-  char16_t         theChar=0;
-  nsresult          result=Peek(theChar);
-  nsScannerIterator origin, current, end;
-
-  origin = mCurrentPosition;
-  current = origin;
-  end = mEndPosition;
-
-  bool done = false;
-  while(current != end) {
-    theChar=*current;
-    if(theChar) {
-      done = (theChar < '0' || theChar > '9') && 
-             ((aBase == 16)? (theChar < 'A' || theChar > 'F') &&
-                             (theChar < 'a' || theChar > 'f')
-                             :true);
-      if(done) {
-        if (!AppendUnicodeTo(origin, current, aString)) {
-          return NS_ERROR_OUT_OF_MEMORY;
-        }
-        break;
-      }
-    }
-    ++current;
-  }
-
-  SetPosition(current);
-  if (current == end) {
-    if (!AppendUnicodeTo(origin, current, aString)) {
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
-    return kEOF;
-  }
-
-  //DoErrTest(aString);
-
-  return result;
-}
-
-/**
- *  Consume characters until you find the terminal char
- *  
- *  @update  gess 3/25/98
- *  @param   aString receives new data from stream
- *  @param   addTerminal tells us whether to append terminal to aString
- *  @return  error code
- */
-nsresult nsScanner::ReadWhitespace(nsScannerSharedSubstring& aString,
-                                   int32_t& aNewlinesSkipped,
-                                   bool& aHaveCR) {
-
-  aHaveCR = false;
-
-  if (!mSlidingBuffer) {
-    return kEOF;
-  }
-
-  char16_t theChar = 0;
-  nsresult  result = Peek(theChar);
-  
-  if (NS_FAILED(result)) {
-    return result;
-  }
-  
-  nsScannerIterator origin, current, end;
-  bool done = false;  
-
-  origin = mCurrentPosition;
-  current = origin;
-  end = mEndPosition;
-
-  bool haveCR = false;
-
-  while(!done && current != end) {
-    switch(theChar) {
-      case '\n':
-      case '\r':
-        {
-          ++aNewlinesSkipped;
-          char16_t thePrevChar = theChar;
-          theChar = (++current != end) ? *current : '\0';
-          if ((thePrevChar == '\r' && theChar == '\n') ||
-              (thePrevChar == '\n' && theChar == '\r')) {
-            theChar = (++current != end) ? *current : '\0'; // CRLF == LFCR => LF
-            haveCR = true;
-          } else if (thePrevChar == '\r') {
-            // Lone CR becomes CRLF; callers should know to remove extra CRs
-            if (!AppendUnicodeTo(origin, current, aString)) {
-              return NS_ERROR_OUT_OF_MEMORY;
-            }
-            aString.writable().Append(char16_t('\n'));
-            origin = current;
-            haveCR = true;
-          }
-        }
-        break;
-      case ' ' :
-      case '\t':
-        theChar = (++current != end) ? *current : '\0';
-        break;
-      default:
-        done = true;
-        if (!AppendUnicodeTo(origin, current, aString)) {
-          return NS_ERROR_OUT_OF_MEMORY;
-        }
-        break;
-    }
-  }
-
-  SetPosition(current);
-  if (current == end) {
-    if (!AppendUnicodeTo(origin, current, aString)) {
-      return NS_ERROR_OUT_OF_MEMORY;
-    }
-    result = kEOF;
-  }
-
-  aHaveCR = haveCR;
-  return result;
-}
-
-//XXXbz callers of this have to manage their lone '\r' themselves if they want
-//it to work.  Good thing they're all in view-source and it deals.
-nsresult nsScanner::ReadWhitespace(nsScannerIterator& aStart, 
-                                   nsScannerIterator& aEnd,
-                                   int32_t& aNewlinesSkipped) {
-
-  if (!mSlidingBuffer) {
-    return kEOF;
-  }
-
-  char16_t theChar = 0;
-  nsresult  result = Peek(theChar);
-  
-  if (NS_FAILED(result)) {
-    return result;
-  }
-  
-  nsScannerIterator origin, current, end;
-  bool done = false;  
-
-  origin = mCurrentPosition;
-  current = origin;
-  end = mEndPosition;
-
-  while(!done && current != end) {
-    switch(theChar) {
-      case '\n':
-      case '\r': ++aNewlinesSkipped;
-      case ' ' :
-      case '\t':
-        {
-          char16_t thePrevChar = theChar;
-          theChar = (++current != end) ? *current : '\0';
-          if ((thePrevChar == '\r' && theChar == '\n') ||
-              (thePrevChar == '\n' && theChar == '\r')) {
-            theChar = (++current != end) ? *current : '\0'; // CRLF == LFCR => LF
-          }
-        }
-        break;
-      default:
-        done = true;
-        aStart = origin;
-        aEnd = current;
-        break;
-    }
-  }
-
-  SetPosition(current);
-  if (current == end) {
-    aStart = origin;
-    aEnd = current;
-    result = kEOF;
-  }
-
-  return result;
-}
-
-/**
- *  Consume characters until you encounter one contained in given
- *  input set.
- *  
- *  @update  gess 3/25/98
- *  @param   aString will contain the result of this method
- *  @param   aTerminalSet is an ordered string that contains
- *           the set of INVALID characters
- *  @return  error code
- */
-nsresult nsScanner::ReadUntil(nsAString& aString,
-                              const nsReadEndCondition& aEndCondition,
-                              bool addTerminal)
-{  
-  if (!mSlidingBuffer) {
-    return kEOF;
-  }
-
-  nsScannerIterator origin, current;
-  const char16_t* setstart = aEndCondition.mChars;
-  const char16_t* setcurrent;
-
-  origin = mCurrentPosition;
-  current = origin;
-
-  char16_t         theChar=0;
-  nsresult          result=Peek(theChar);
-
-  if (NS_FAILED(result)) {
-    return result;
-  }
-  
-  while (current != mEndPosition) {
-    theChar = *current;
-    if (theChar == '\0') {
-      ReplaceCharacter(current, sInvalid);
-      theChar = sInvalid;
-    }
-
-    // Filter out completely wrong characters
-    // Check if all bits are in the required area
-    if(!(theChar & aEndCondition.mFilter)) {
-      // They were. Do a thorough check.
-
-      setcurrent = setstart;
-      while (*setcurrent) {
-        if (*setcurrent == theChar) {
-          if(addTerminal)
-            ++current;
-          if (!AppendUnicodeTo(origin, current, aString)) {
-            return NS_ERROR_OUT_OF_MEMORY;
-          }
-          SetPosition(current);
-
-          //DoErrTest(aString);
-
-          return NS_OK;
-        }
-        ++setcurrent;
-      }
-    }
-    
-    ++current;
-  }
-
-  // If we are here, we didn't find any terminator in the string and
-  // current = mEndPosition
-  SetPosition(current);
-  if (!AppendUnicodeTo(origin, current, aString)) {
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
-  return kEOF;
-}
-
-nsresult nsScanner::ReadUntil(nsScannerSharedSubstring& aString,
-                              const nsReadEndCondition& aEndCondition,
-                              bool addTerminal)
-{  
-  if (!mSlidingBuffer) {
-    return kEOF;
-  }
-
-  nsScannerIterator origin, current;
-  const char16_t* setstart = aEndCondition.mChars;
-  const char16_t* setcurrent;
-
-  origin = mCurrentPosition;
-  current = origin;
-
-  char16_t         theChar=0;
-  nsresult          result=Peek(theChar);
-
-  if (NS_FAILED(result)) {
-    return result;
-  }
-  
-  while (current != mEndPosition) {
-    theChar = *current;
-    if (theChar == '\0') {
-      ReplaceCharacter(current, sInvalid);
-      theChar = sInvalid;
-    }
-
-    // Filter out completely wrong characters
-    // Check if all bits are in the required area
-    if(!(theChar & aEndCondition.mFilter)) {
-      // They were. Do a thorough check.
-
-      setcurrent = setstart;
-      while (*setcurrent) {
-        if (*setcurrent == theChar) {
-          if(addTerminal)
-            ++current;
-          if (!AppendUnicodeTo(origin, current, aString)) {
-            return NS_ERROR_OUT_OF_MEMORY;
-          }
-          SetPosition(current);
-
-          //DoErrTest(aString);
-
-          return NS_OK;
-        }
-        ++setcurrent;
-      }
-    }
-    
-    ++current;
-  }
-
-  // If we are here, we didn't find any terminator in the string and
-  // current = mEndPosition
-  SetPosition(current);
-  if (!AppendUnicodeTo(origin, current, aString)) {
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
-  return kEOF;
-}
-
-nsresult nsScanner::ReadUntil(nsScannerIterator& aStart, 
-                              nsScannerIterator& aEnd,
-                              const nsReadEndCondition &aEndCondition,
-                              bool addTerminal)
-{
-  if (!mSlidingBuffer) {
-    return kEOF;
-  }
-
-  nsScannerIterator origin, current;
-  const char16_t* setstart = aEndCondition.mChars;
-  const char16_t* setcurrent;
-
-  origin = mCurrentPosition;
-  current = origin;
-
-  char16_t         theChar=0;
-  nsresult          result=Peek(theChar);
-  
-  if (NS_FAILED(result)) {
-    aStart = aEnd = current;
-    return result;
-  }
-  
-  while (current != mEndPosition) {
-    theChar = *current;
-    if (theChar == '\0') {
-      ReplaceCharacter(current, sInvalid);
-      theChar = sInvalid;
-    }
-
-    // Filter out completely wrong characters
-    // Check if all bits are in the required area
-    if(!(theChar & aEndCondition.mFilter)) {
-      // They were. Do a thorough check.
-      setcurrent = setstart;
-      while (*setcurrent) {
-        if (*setcurrent == theChar) {
-          if(addTerminal)
-            ++current;
-          aStart = origin;
-          aEnd = current;
-          SetPosition(current);
-
-          return NS_OK;
-        }
-        ++setcurrent;
-      }
-    }
-
-    ++current;
-  }
-
-  // If we are here, we didn't find any terminator in the string and
-  // current = mEndPosition
-  SetPosition(current);
-  aStart = origin;
-  aEnd = current;
-  return kEOF;
-}
-
-/**
- *  Consumes chars until you see the given terminalChar
- *  
- *  @update  gess 3/25/98
- *  @param   
- *  @return  error code
- */
-nsresult nsScanner::ReadUntil(nsAString& aString,
-                              char16_t aTerminalChar,
-                              bool addTerminal)
-{
-  if (!mSlidingBuffer) {
-    return kEOF;
-  }
-
-  nsScannerIterator origin, current;
-
-  origin = mCurrentPosition;
-  current = origin;
-
-  char16_t theChar;
-  nsresult result = Peek(theChar);
-
-  if (NS_FAILED(result)) {
-    return result;
-  }
-
-  while (current != mEndPosition) {
-    theChar = *current;
-    if (theChar == '\0') {
-      ReplaceCharacter(current, sInvalid);
-      theChar = sInvalid;
-    }
-
-    if (aTerminalChar == theChar) {
-      if(addTerminal)
-        ++current;
-      if (!AppendUnicodeTo(origin, current, aString)) {
-        return NS_ERROR_OUT_OF_MEMORY;
-      }
-      SetPosition(current);
-      return NS_OK;
-    }
-    ++current;
-  }
-
-  // If we are here, we didn't find any terminator in the string and
-  // current = mEndPosition
-  if (!AppendUnicodeTo(origin, current, aString)) {
-    return NS_ERROR_OUT_OF_MEMORY;
-  }
-  SetPosition(current);
-  return kEOF;
-
-}
-
 void nsScanner::BindSubstring(nsScannerSubstring& aSubstring, const nsScannerIterator& aStart, const nsScannerIterator& aEnd)
 {
   aSubstring.Rebind(*mSlidingBuffer, aStart, aEnd);
 }
 
 void nsScanner::CurrentPosition(nsScannerIterator& aPosition)
 {
   aPosition = mCurrentPosition;
diff --git a/parser/htmlparser/nsScanner.h b/parser/htmlparser/nsScanner.h
--- a/parser/htmlparser/nsScanner.h
+++ b/parser/htmlparser/nsScanner.h
@@ -68,93 +68,16 @@ class nsScanner {
        *  @param   ch is the char to accept new value
        *  @return  error code reflecting read status
        */
       nsresult Peek(char16_t& ch, uint32_t aOffset=0);
 
       nsresult Peek(nsAString& aStr, int32_t aNumChars, int32_t aOffset = 0);
 
       /**
-       *  Skip over chars as long as they equal given char
-       *  
-       *  @update  gess 3/25/98
-       *  @param   char to be skipped
-       *  @return  error code
-       */
-      nsresult SkipOver(char16_t aSkipChar);
-
-      /**
-       *  Skip whitespace on scanner input stream
-       *  
-       *  @update  gess 3/25/98
-       *  @return  error status
-       */
-      nsresult SkipWhitespace(int32_t& aNewlinesSkipped);
-
-      /**
-       *  Consume characters until you run into space, a '<', a '>', or a '/'.
-       *  
-       *  @param   aString - receives new data from stream
-       *  @return  error code
-       */
-      nsresult ReadTagIdentifier(nsScannerSharedSubstring& aString);
-
-      /**
-       *  Consume characters until you run into a char that's not valid in an
-       *  entity name
-       *  
-       *  @param   aString - receives new data from stream
-       *  @return  error code
-       */
-      nsresult ReadEntityIdentifier(nsString& aString);
-      nsresult ReadNumber(nsString& aString,int32_t aBase);
-      nsresult ReadWhitespace(nsScannerSharedSubstring& aString, 
-                              int32_t& aNewlinesSkipped,
-                              bool& aHaveCR);
-      nsresult ReadWhitespace(nsScannerIterator& aStart, 
-                              nsScannerIterator& aEnd,
-                              int32_t& aNewlinesSkipped);
-
-      /**
-       *  Consume characters until you find the terminal char
-       *  
-       *  @update  gess 3/25/98
-       *  @param   aString receives new data from stream
-       *  @param   aTerminal contains terminating char
-       *  @param   addTerminal tells us whether to append terminal to aString
-       *  @return  error code
-       */
-      nsresult ReadUntil(nsAString& aString,
-                         char16_t aTerminal,
-                         bool addTerminal);
-
-      /**
-       *  Consume characters until you find one contained in given
-       *  terminal set.
-       *  
-       *  @update  gess 3/25/98
-       *  @param   aString receives new data from stream
-       *  @param   aTermSet contains set of terminating chars
-       *  @param   addTerminal tells us whether to append terminal to aString
-       *  @return  error code
-       */
-      nsresult ReadUntil(nsAString& aString,
-                         const nsReadEndCondition& aEndCondition, 
-                         bool addTerminal);
-
-      nsresult ReadUntil(nsScannerSharedSubstring& aString,
-                         const nsReadEndCondition& aEndCondition,
-                         bool addTerminal);
-
-      nsresult ReadUntil(nsScannerIterator& aStart,
-                         nsScannerIterator& aEnd,
-                         const nsReadEndCondition& aEndCondition, 
-                         bool addTerminal);
-
-      /**
        *  Records current offset position in input stream. This allows us
        *  to back up to this point if the need should arise, such as when
        *  tokenization gets interrupted.
        *  
        *  @update  gess 5/12/98
        *  @param   
        *  @return  
        */
