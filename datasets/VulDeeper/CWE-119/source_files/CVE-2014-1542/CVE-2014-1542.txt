diff --git a/content/media/webaudio/AudioContext.cpp b/content/media/webaudio/AudioContext.cpp
--- a/content/media/webaudio/AudioContext.cpp
+++ b/content/media/webaudio/AudioContext.cpp
@@ -178,17 +178,19 @@ AudioContext::CreateBufferSource()
   return bufferNode.forget();
 }
 
 already_AddRefed<AudioBuffer>
 AudioContext::CreateBuffer(JSContext* aJSContext, uint32_t aNumberOfChannels,
                            uint32_t aLength, float aSampleRate,
                            ErrorResult& aRv)
 {
-  if (aSampleRate < 8000 || aSampleRate > 192000 || !aLength || !aNumberOfChannels) {
+  if (aSampleRate < WebAudioUtils::MinSampleRate ||
+      aSampleRate > WebAudioUtils::MaxSampleRate ||
+      !aLength || !aNumberOfChannels) {
     aRv.Throw(NS_ERROR_DOM_INDEX_SIZE_ERR);
     return nullptr;
   }
 
   if (aLength > INT32_MAX) {
     aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
     return nullptr;
   }
diff --git a/content/media/webaudio/WebAudioUtils.cpp b/content/media/webaudio/WebAudioUtils.cpp
--- a/content/media/webaudio/WebAudioUtils.cpp
+++ b/content/media/webaudio/WebAudioUtils.cpp
@@ -9,20 +9,16 @@
 #include "AudioParamTimeline.h"
 #include "blink/HRTFDatabaseLoader.h"
 #include "speex/speex_resampler.h"
 
 namespace mozilla {
 
 namespace dom {
 
-// 32 is the minimum required by the spec and matches what is used by blink.
-// The limit protects against large memory allocations.
-const uint32_t WebAudioUtils::MaxChannelCount = 32;
-
 struct ConvertTimeToTickHelper
 {
   AudioNodeStream* mSourceStream;
   AudioNodeStream* mDestinationStream;
 
   static int64_t Convert(double aTime, void* aClosure)
   {
     ConvertTimeToTickHelper* This = static_cast<ConvertTimeToTickHelper*> (aClosure);
diff --git a/content/media/webaudio/WebAudioUtils.h b/content/media/webaudio/WebAudioUtils.h
--- a/content/media/webaudio/WebAudioUtils.h
+++ b/content/media/webaudio/WebAudioUtils.h
@@ -20,90 +20,97 @@ namespace mozilla {
 
 class AudioNodeStream;
 class MediaStream;
 
 namespace dom {
 
 class AudioParamTimeline;
 
-struct WebAudioUtils {
-  static const uint32_t MaxChannelCount;
+namespace WebAudioUtils {
+  // 32 is the minimum required by the spec for createBuffer() and
+  // createScriptProcessor() and matches what is used by Blink.  The limit
+  // protects against large memory allocations.
+  const uint32_t MaxChannelCount = 32;
+  // AudioContext::CreateBuffer() "must support sample-rates in at least the
+  // range 22050 to 96000."
+  const uint32_t MinSampleRate = 8000;
+  const uint32_t MaxSampleRate = 192000;
 
-  static bool FuzzyEqual(float v1, float v2)
+  inline bool FuzzyEqual(float v1, float v2)
   {
     using namespace std;
     return fabsf(v1 - v2) < 1e-7f;
   }
-  static bool FuzzyEqual(double v1, double v2)
+  inline bool FuzzyEqual(double v1, double v2)
   {
     using namespace std;
     return fabs(v1 - v2) < 1e-7;
   }
 
   /**
    * Computes an exponential smoothing rate for a time based variable
    * over aDuration seconds.
    */
-  static double ComputeSmoothingRate(double aDuration, double aSampleRate)
+  inline double ComputeSmoothingRate(double aDuration, double aSampleRate)
   {
     return 1.0 - std::exp(-1.0 / (aDuration * aSampleRate));
   }
 
   /**
    * Converts AudioParamTimeline floating point time values to tick values
    * with respect to a source and a destination AudioNodeStream.
    *
    * This needs to be called for each AudioParamTimeline that gets sent to an
    * AudioNodeEngine on the engine side where the AudioParamTimeline is
    * received.  This means that such engines need to be aware of their source
    * and destination streams as well.
    */
-  static void ConvertAudioParamToTicks(AudioParamTimeline& aParam,
-                                       AudioNodeStream* aSource,
-                                       AudioNodeStream* aDest);
+  void ConvertAudioParamToTicks(AudioParamTimeline& aParam,
+                                AudioNodeStream* aSource,
+                                AudioNodeStream* aDest);
 
   /**
    * Converts a linear value to decibels.  Returns aMinDecibels if the linear
    * value is 0.
    */
-  static float ConvertLinearToDecibels(float aLinearValue, float aMinDecibels)
+  inline float ConvertLinearToDecibels(float aLinearValue, float aMinDecibels)
   {
     return aLinearValue ? 20.0f * std::log10(aLinearValue) : aMinDecibels;
   }
 
   /**
    * Converts a decibel value to a linear value.
    */
-  static float ConvertDecibelsToLinear(float aDecibels)
+  inline float ConvertDecibelsToLinear(float aDecibels)
   {
     return std::pow(10.0f, 0.05f * aDecibels);
   }
 
   /**
    * Converts a decibel to a linear value.
    */
-  static float ConvertDecibelToLinear(float aDecibel)
+  inline float ConvertDecibelToLinear(float aDecibel)
   {
     return std::pow(10.0f, 0.05f * aDecibel);
   }
 
-  static void FixNaN(double& aDouble)
+  inline void FixNaN(double& aDouble)
   {
     if (IsNaN(aDouble) || IsInfinite(aDouble)) {
       aDouble = 0.0;
     }
   }
 
-  static double DiscreteTimeConstantForSampleRate(double timeConstant, double sampleRate)
+  inline double DiscreteTimeConstantForSampleRate(double timeConstant, double sampleRate)
   {
     return 1.0 - std::exp(-1.0 / (sampleRate * timeConstant));
   }
 
-  static bool IsTimeValid(double aTime)
+  inline bool IsTimeValid(double aTime)
   {
     return aTime >= 0 &&  aTime <= (MEDIA_TIME_MAX >> MEDIA_TIME_FRAC_BITS);
   }
 
   /**
    * Converts a floating point value to an integral type in a safe and
    * platform agnostic way.  The following program demonstrates the kinds
    * of ways things can go wrong depending on the CPU architecture you're
@@ -161,17 +168,17 @@ struct WebAudioUtils {
    *  999999995904.000000 2147483647
    *  nan 0
    *
    * Note that the caller is responsible to make sure that the value
    * passed to this function is not a NaN.  This function will abort if
    * it sees a NaN.
    */
   template <typename IntType, typename FloatType>
-  static IntType TruncateFloatToInt(FloatType f)
+  IntType TruncateFloatToInt(FloatType f)
   {
     using namespace std;
 
     static_assert(mozilla::IsIntegral<IntType>::value == true,
                   "IntType must be an integral type");
     static_assert(mozilla::IsFloatingPoint<FloatType>::value == true,
                   "FloatType must be a floating point type");
 
@@ -192,28 +199,28 @@ struct WebAudioUtils {
       // integral value for this type, just clamp to the minimum value.
       return numeric_limits<IntType>::min();
     }
 
     // Otherwise, this conversion must be well defined.
     return IntType(f);
   }
 
-  static void Shutdown();
+  void Shutdown();
 
-  static int
+  int
   SpeexResamplerProcess(SpeexResamplerState* aResampler,
                         uint32_t aChannel,
                         const float* aIn, uint32_t* aInLen,
                         float* aOut, uint32_t* aOutLen);
 
-  static int
+  int
   SpeexResamplerProcess(SpeexResamplerState* aResampler,
                         uint32_t aChannel,
                         const int16_t* aIn, uint32_t* aInLen,
                         float* aOut, uint32_t* aOutLen);
-};
+}
 
 }
 }
 
 #endif
 
diff --git a/content/media/webaudio/blink/DynamicsCompressorKernel.cpp b/content/media/webaudio/blink/DynamicsCompressorKernel.cpp
--- a/content/media/webaudio/blink/DynamicsCompressorKernel.cpp
+++ b/content/media/webaudio/blink/DynamicsCompressorKernel.cpp
@@ -32,17 +32,17 @@
 #include <algorithm>
 
 #include "mozilla/FloatingPoint.h"
 #include "mozilla/Constants.h"
 #include "WebAudioUtils.h"
 
 using namespace std;
 
-using mozilla::dom::WebAudioUtils;
+using namespace mozilla::dom; // for WebAudioUtils
 using mozilla::IsInfinite;
 using mozilla::IsNaN;
 
 namespace WebCore {
 
 
 // Metering hits peaks instantly, but releases this fast (in seconds).
 const float meteringReleaseTimeConstant = 0.325f;
