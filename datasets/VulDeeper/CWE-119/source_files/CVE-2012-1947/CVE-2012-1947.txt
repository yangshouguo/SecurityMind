diff --git a/xpcom/io/nsNativeCharsetUtils.cpp b/xpcom/io/nsNativeCharsetUtils.cpp
--- a/xpcom/io/nsNativeCharsetUtils.cpp
+++ b/xpcom/io/nsNativeCharsetUtils.cpp
@@ -559,19 +559,19 @@ nsNativeCharsetConverter::UnicodeToNativ
 {
     size_t res = 0;
     size_t inLeft = (size_t) *inputLeft * 2;
     size_t outLeft = (size_t) *outputLeft;
 
     if (gUnicodeToNative != INVALID_ICONV_T) {
         res = xp_iconv(gUnicodeToNative, (const char **) input, &inLeft, output, &outLeft);
 
+        *inputLeft = inLeft / 2;
+        *outputLeft = outLeft;
         if (res != (size_t) -1) {
-            *inputLeft = inLeft / 2;
-            *outputLeft = outLeft;
             return NS_OK;
         }
 
         NS_ERROR("iconv failed");
 
         // reset converter
         xp_iconv_reset(gUnicodeToNative);
     }
@@ -602,30 +602,31 @@ nsNativeCharsetConverter::UnicodeToNativ
                 }
                 else
                     NS_ERROR("conversion from utf-8 to native failed");
                 break;
             }
             inLeft -= sizeof(PRUnichar);
         }
 
+        (*input) += (*inputLeft - inLeft / 2);
+        *inputLeft = inLeft / 2;
+        *outputLeft = outLeft;
         if (res != (size_t) -1) {
-            (*input) += (*inputLeft - inLeft/2);
-            *inputLeft = inLeft/2;
-            *outputLeft = outLeft;
             return NS_OK;
         }
 
         // reset converters
         xp_iconv_reset(gUnicodeToUTF8);
         xp_iconv_reset(gUTF8ToNative);
     }
 #endif
 
     // fallback: truncate and hope for the best
+    // XXX This is lame and we have to do better.
     utf16_to_isolatin1(input, inputLeft, output, outputLeft);
 
     return NS_OK;
 }
 
 bool
 nsNativeCharsetConverter::IsNativeUTF8()
 {

