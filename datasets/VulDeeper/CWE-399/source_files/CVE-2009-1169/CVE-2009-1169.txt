diff --git a/content/xslt/src/xslt/txKeyFunctionCall.cpp b/content/xslt/src/xslt/txKeyFunctionCall.cpp
--- a/content/xslt/src/xslt/txKeyFunctionCall.cpp
+++ b/content/xslt/src/xslt/txKeyFunctionCall.cpp
@@ -383,26 +383,29 @@ nsresult txXSLKey::testNode(const txXPat
                             txKeyValueHashKey& aKey,
                             txKeyValueHash& aKeyValueHash,
                             txExecutionState& aEs)
 {
     nsAutoString val;
     PRUint32 currKey, numKeys = mKeys.Length();
     for (currKey = 0; currKey < numKeys; ++currKey) {
         if (mKeys[currKey].matchPattern->matches(aNode, &aEs)) {
-            txSingleNodeContext evalContext(aNode, &aEs);
-            nsresult rv = aEs.pushEvalContext(&evalContext);
+            txSingleNodeContext *evalContext =
+                new txSingleNodeContext(aNode, &aEs);
+            NS_ENSURE_TRUE(evalContext, NS_ERROR_OUT_OF_MEMORY);
+
+            nsresult rv = aEs.pushEvalContext(evalContext);
             NS_ENSURE_SUCCESS(rv, rv);
 
             nsRefPtr<txAExprResult> exprResult;
-            rv = mKeys[currKey].useExpr->evaluate(&evalContext,
+            rv = mKeys[currKey].useExpr->evaluate(evalContext,
                                                   getter_AddRefs(exprResult));
+            NS_ENSURE_SUCCESS(rv, rv);
 
-            aEs.popEvalContext();
-            NS_ENSURE_SUCCESS(rv, rv);
+            delete aEs.popEvalContext();
 
             if (exprResult->getResultType() == txAExprResult::NODESET) {
                 txNodeSet* res = static_cast<txNodeSet*>
                                             (static_cast<txAExprResult*>
                                                         (exprResult));
                 PRInt32 i;
                 for (i = 0; i < res->size(); ++i) {
                     val.Truncate();
