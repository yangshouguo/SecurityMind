diff --git a/content/base/src/nsNodeIterator.cpp b/content/base/src/nsNodeIterator.cpp
--- a/content/base/src/nsNodeIterator.cpp
+++ b/content/base/src/nsNodeIterator.cpp
@@ -278,68 +278,59 @@ NS_IMETHODIMP nsNodeIterator::GetExpandE
 {
     *aExpandEntityReferences = mExpandEntityReferences;
     return NS_OK;
 }
 
 /* nsIDOMNode nextNode ()  raises (DOMException); */
 NS_IMETHODIMP nsNodeIterator::NextNode(nsIDOMNode **_retval)
 {
-    nsresult rv;
-    PRInt16 filtered;
-
-    *_retval = nsnull;
-
-    if (mDetached)
-        return NS_ERROR_DOM_INVALID_STATE_ERR;
-
-    mWorkingPointer = mPointer;
-
-    while (mWorkingPointer.MoveToNext(mRoot)) {
-        nsCOMPtr<nsINode> testNode = mWorkingPointer.mNode;
-        rv = TestNode(testNode, &filtered);
-        NS_ENSURE_SUCCESS(rv, rv);
-
-        if (filtered == nsIDOMNodeFilter::FILTER_ACCEPT) {
-            mPointer = mWorkingPointer;
-            mWorkingPointer.Clear();
-            return CallQueryInterface(testNode, _retval);
-        }
-    }
-
-    mWorkingPointer.Clear();
-    return NS_OK;
+    return NextOrPrevNode(&NodePointer::MoveToNext, _retval);
 }
 
 /* nsIDOMNode previousNode ()  raises (DOMException); */
 NS_IMETHODIMP nsNodeIterator::PreviousNode(nsIDOMNode **_retval)
 {
+    return NextOrPrevNode(&NodePointer::MoveToPrevious, _retval);
+}
+
+nsresult
+nsNodeIterator::NextOrPrevNode(NodePointer::MoveToMethodType aMove,
+                               nsIDOMNode **_retval)
+{
     nsresult rv;
     PRInt16 filtered;
 
     *_retval = nsnull;
 
     if (mDetached)
         return NS_ERROR_DOM_INVALID_STATE_ERR;
 
     mWorkingPointer = mPointer;
 
-    while (mWorkingPointer.MoveToPrevious(mRoot)) {
+    struct AutoClear {
+        NodePointer* mPtr;
+        AutoClear(NodePointer* ptr) : mPtr(ptr) {}
+       ~AutoClear() { mPtr->Clear(); }
+    } ac(&mWorkingPointer);
+
+    while ((mWorkingPointer.*aMove)(mRoot)) {
         nsCOMPtr<nsINode> testNode = mWorkingPointer.mNode;
         rv = TestNode(testNode, &filtered);
         NS_ENSURE_SUCCESS(rv, rv);
 
+        if (mDetached)
+            return NS_ERROR_DOM_INVALID_STATE_ERR;
+
         if (filtered == nsIDOMNodeFilter::FILTER_ACCEPT) {
             mPointer = mWorkingPointer;
-            mWorkingPointer.Clear();
             return CallQueryInterface(testNode, _retval);
         }
     }
 
-    mWorkingPointer.Clear();
     return NS_OK;
 }
 
 /* void detach (); */
 NS_IMETHODIMP nsNodeIterator::Detach(void)
 {
     if (!mDetached) {
         mRoot->RemoveMutationObserver(this);
diff --git a/content/base/src/nsNodeIterator.h b/content/base/src/nsNodeIterator.h
--- a/content/base/src/nsNodeIterator.h
+++ b/content/base/src/nsNodeIterator.h
@@ -72,16 +72,17 @@ public:
 
     NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsNodeIterator, nsIDOMNodeIterator)
 
 private:
     struct NodePointer {
         NodePointer() : mNode(nsnull) {};
         NodePointer(nsINode *aNode, PRBool aBeforeNode);
 
+        typedef PRBool (NodePointer::*MoveToMethodType)(nsINode*);
         PRBool MoveToNext(nsINode *aRoot);
         PRBool MoveToPrevious(nsINode *aRoot);
 
         PRBool MoveForward(nsINode *aRoot, nsINode *aParent, PRInt32 aChildNum);
         void MoveBackward(nsINode *aParent, PRInt32 aChildNum);
 
         void AdjustAfterInsertion(nsINode *aRoot, nsINode *aContainer, PRInt32 aIndexInContainer);
         void AdjustAfterRemoval(nsINode *aRoot, nsINode *aContainer, nsIContent *aChild, PRInt32 aIndexInContainer);
@@ -93,14 +94,18 @@ private:
         // points to the root
         nsINode *mNodeParent;
         PRBool mBeforeNode;
         // mNode's index in mNodeParent. Uninitialized if mNodeParent is null
         // or dangling (per above comment).
         PRInt32 mIndexInParent;
     };
 
+    inline nsresult
+    NextOrPrevNode(NodePointer::MoveToMethodType aMove,
+                   nsIDOMNode **_retval);
+
     PRBool mDetached;
     NodePointer mPointer;
     NodePointer mWorkingPointer;
 };
 
 #endif
