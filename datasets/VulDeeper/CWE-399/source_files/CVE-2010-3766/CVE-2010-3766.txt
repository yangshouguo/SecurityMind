diff --git a/content/base/public/Makefile.in b/content/base/public/Makefile.in
--- a/content/base/public/Makefile.in
+++ b/content/base/public/Makefile.in
@@ -52,16 +52,17 @@ nsIAttribute.h \
 nsIContentIterator.h \
 nsContentErrors.h \
 nsContentPolicyUtils.h \
 nsContentUtils.h \
 nsIContentUtils.h \
 nsIDocument.h \
 nsIDocumentObserver.h \
 nsIMutationObserver.h \
+nsIMutationObserver2.h \
 nsINameSpaceManager.h \
 nsINode.h \
 nsINodeInfo.h \
 nsINodeList.h \
 nsIRange.h \
 nsIRangeUtils.h \
 nsIScriptElement.h \
 nsIStyleSheetLinkingElement.h \
diff --git a/content/base/public/nsIMutationObserver2.h b/content/base/public/nsIMutationObserver2.h
new file mode 100644
--- /dev/null
+++ b/content/base/public/nsIMutationObserver2.h
@@ -0,0 +1,90 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* ***** BEGIN LICENSE BLOCK *****
+ * Version: MPL 1.1/GPL 2.0/LGPL 2.1
+ *
+ * The contents of this file are subject to the Mozilla Public License Version
+ * 1.1 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * http://www.mozilla.org/MPL/
+ *
+ * Software distributed under the License is distributed on an "AS IS" basis,
+ * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
+ * for the specific language governing rights and limitations under the
+ * License.
+ *
+ * The Original Code is mozilla.org code.
+ *
+ * The Initial Developer of the Original Code is Mozilla Foundation.
+ * Portions created by the Initial Developer are Copyright (C) 1998
+ * the Initial Developer. All Rights Reserved.
+ *
+ * Contributor(s):
+ * Mounir Lamouri <mounir.lamouri@mozilla.com> (Original author)
+ *
+ * Alternatively, the contents of this file may be used under the terms of
+ * either of the GNU General Public License Version 2 or later (the "GPL"),
+ * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
+ * in which case the provisions of the GPL or the LGPL are applicable instead
+ * of those above. If you wish to allow use of your version of this file only
+ * under the terms of either the GPL or the LGPL, and not to allow others to
+ * use your version of this file under the terms of the MPL, indicate your
+ * decision by deleting the provisions above and replace them with the notice
+ * and other provisions required by the GPL or the LGPL. If you do not delete
+ * the provisions above, a recipient may use your version of this file under
+ * the terms of any one of the MPL, the GPL or the LGPL.
+ *
+ * ***** END LICENSE BLOCK ***** */
+
+#ifndef nsIMutationObserver2_h___
+#define nsIMutationObserver2_h___
+
+#include "nsIMutationObserver.h"
+
+class nsIContent;
+class nsINode;
+
+#define NS_IMUTATION_OBSERVER_2_IID \
+{0x61ac1cfd, 0xf3ef, 0x4408, \
+  {0x8a, 0x72, 0xee, 0xf0, 0x41, 0xbe, 0xc7, 0xe9 } }
+
+/**
+ * Mutation observer interface 2 is adding AttributeChildRemoved to
+ * nsIMutationObserver.
+ *
+ * @see nsIMutationObserver.
+ */
+class nsIMutationObserver2 : public nsIMutationObserver
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_IMUTATION_OBSERVER_2_IID)
+
+  /**
+   * Notification that an attribute's child has been removed.
+   *
+   * @param aContainer The attribute that had its child removed.
+   * @param aChild     The child that was removed.
+   */
+  virtual void AttributeChildRemoved(nsINode* aAttribute,
+                                     nsIContent* aChild) = 0;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsIMutationObserver2, NS_IMUTATION_OBSERVER_2_IID)
+
+#define NS_DECL_NSIMUTATIONOBSERVER2_ATTRIBUTECHILDREMOVED                \
+    virtual void AttributeChildRemoved(nsINode* aAttribute,               \
+                                       nsIContent* aChild);
+
+#define NS_DECL_NSIMUTATIONOBSERVER2                                      \
+    NS_DECL_NSIMUTATIONOBSERVER                                           \
+    NS_DECL_NSIMUTATIONOBSERVER2_ATTRIBUTECHILDREMOVED
+
+#define NS_IMPL_NSIMUTATIONOBSERVER2_CONTENT(_class)                      \
+NS_IMPL_NSIMUTATIONOBSERVER_CONTENT(_class)                               \
+void                                                                      \
+_class::AttributeChildRemoved(nsINode* aAttribute, nsIContent *aChild)    \
+{                                                                         \
+}
+
+
+#endif /* nsIMutationObserver2_h___ */
+
diff --git a/content/base/src/nsDOMAttribute.cpp b/content/base/src/nsDOMAttribute.cpp
--- a/content/base/src/nsDOMAttribute.cpp
+++ b/content/base/src/nsDOMAttribute.cpp
@@ -728,16 +728,21 @@ nsDOMAttribute::RemoveChildAt(PRUint32 a
     mutation.mRelatedNode =
       do_QueryInterface(static_cast<nsIAttribute*>(this));
     subtree.UpdateTarget(GetOwnerDoc(), this);
     nsEventDispatcher::Dispatch(mChild, nsnull, &mutation);
   }
   if (guard.Mutated(0) && mChild != child) {
     return NS_OK;
   }
+
+  if (aNotify) {
+    nsNodeUtils::AttributeChildRemoved(this, mChild);
+  }
+
   NS_RELEASE(mChild);
   static_cast<nsTextNode*>(child.get())->UnbindFromAttribute();
 
   nsString nullString;
   SetDOMStringToNull(nullString);
   SetValue(nullString);
   return NS_OK;
 }
diff --git a/content/base/src/nsNodeIterator.cpp b/content/base/src/nsNodeIterator.cpp
--- a/content/base/src/nsNodeIterator.cpp
+++ b/content/base/src/nsNodeIterator.cpp
@@ -212,17 +212,17 @@ NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsNodeIterator)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mRoot)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFilter)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 // QueryInterface implementation for nsNodeIterator
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsNodeIterator)
     NS_INTERFACE_MAP_ENTRY(nsIDOMNodeIterator)
-    NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
+    NS_INTERFACE_MAP_ENTRY(nsIMutationObserver2)
     NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMNodeIterator)
     NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(NodeIterator)
 NS_INTERFACE_MAP_END
 
 NS_IMPL_CYCLE_COLLECTING_ADDREF(nsNodeIterator)
 NS_IMPL_CYCLE_COLLECTING_RELEASE(nsNodeIterator)
 
 /* readonly attribute nsIDOMNode root; */
@@ -361,8 +361,16 @@ void nsNodeIterator::ContentRemoved(nsID
                                     nsIContent *aChild,
                                     PRInt32 aIndexInContainer)
 {
     nsINode *container = NODE_FROM(aContainer, aDocument);
 
     mPointer.AdjustAfterRemoval(mRoot, container, aChild, aIndexInContainer);
     mWorkingPointer.AdjustAfterRemoval(mRoot, container, aChild, aIndexInContainer);
 }
+
+void nsNodeIterator::AttributeChildRemoved(nsINode* aAttribute,
+                                           nsIContent* aChild)
+{
+  mPointer.AdjustAfterRemoval(mRoot, aAttribute, aChild, 0);
+  mWorkingPointer.AdjustAfterRemoval(mRoot, aAttribute, aChild, 0);
+}
+
diff --git a/content/base/src/nsNodeIterator.h b/content/base/src/nsNodeIterator.h
--- a/content/base/src/nsNodeIterator.h
+++ b/content/base/src/nsNodeIterator.h
@@ -50,30 +50,31 @@
 #include "nsStubMutationObserver.h"
 
 class nsINode;
 class nsIDOMNode;
 class nsIDOMNodeFilter;
 
 class nsNodeIterator : public nsIDOMNodeIterator,
                        public nsTraversal,
-                       public nsStubMutationObserver
+                       public nsStubMutationObserver2
 {
 public:
     NS_DECL_CYCLE_COLLECTING_ISUPPORTS
     NS_DECL_NSIDOMNODEITERATOR
 
     nsNodeIterator(nsINode *aRoot,
                    PRUint32 aWhatToShow,
                    nsIDOMNodeFilter *aFilter,
                    PRBool aExpandEntityReferences);
     virtual ~nsNodeIterator();
 
     NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
     NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
+    NS_DECL_NSIMUTATIONOBSERVER2_ATTRIBUTECHILDREMOVED
 
     NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsNodeIterator, nsIDOMNodeIterator)
 
 private:
     struct NodePointer {
         NodePointer() : mNode(nsnull) {};
         NodePointer(nsINode *aNode, PRBool aBeforeNode);
 
diff --git a/content/base/src/nsNodeUtils.cpp b/content/base/src/nsNodeUtils.cpp
--- a/content/base/src/nsNodeUtils.cpp
+++ b/content/base/src/nsNodeUtils.cpp
@@ -35,16 +35,17 @@
  *
  * ***** END LICENSE BLOCK ***** */
 
 #include "nsNodeUtils.h"
 #include "nsContentUtils.h"
 #include "nsINode.h"
 #include "nsIContent.h"
 #include "nsIMutationObserver.h"
+#include "nsIMutationObserver2.h"
 #include "nsIDocument.h"
 #include "nsIDOMUserDataHandler.h"
 #include "nsIEventListenerManager.h"
 #include "nsIAttribute.h"
 #include "nsIXPConnect.h"
 #include "nsGenericElement.h"
 #include "pldhash.h"
 #include "nsIDOMAttr.h"
@@ -77,17 +78,16 @@
       NS_OBSERVER_ARRAY_NOTIFY_OBSERVERS(                         \
         slots->mMutationObservers, nsIMutationObserver,           \
         func_, params_);                                          \
     }                                                             \
     node = node->GetNodeParent();                                 \
   } while (node);                                                 \
   PR_END_MACRO
 
-
 void
 nsNodeUtils::CharacterDataWillChange(nsIContent* aContent,
                                      CharacterDataChangeInfo* aInfo)
 {
   nsIDocument* doc = aContent->GetOwnerDoc();
   IMPL_MUTATION_NOTIFICATION(CharacterDataWillChange, aContent,
                              (doc, aContent, aInfo));
 }
@@ -180,16 +180,42 @@ nsNodeUtils::ContentRemoved(nsINode* aCo
     document = static_cast<nsIDocument*>(aContainer);
   }
 
   IMPL_MUTATION_NOTIFICATION(ContentRemoved, aContainer,
                              (document, container, aChild, aIndexInContainer));
 }
 
 void
+nsNodeUtils::AttributeChildRemoved(nsINode* aAttribute,
+                                   nsIContent* aChild)
+{
+  NS_PRECONDITION(aAttribute->IsNodeOfType(nsINode::eATTRIBUTE),
+                  "container must be a nsIAttribute");
+
+  // This is a variant of IMPL_MUTATION_NOTIFICATION.
+  do {
+    nsINode::nsSlots* slots = aAttribute->GetExistingSlots();
+    if (slots && !slots->mMutationObservers.IsEmpty()) {
+      // This is a variant of NS_OBSERVER_ARRAY_NOTIFY_OBSERVERS.
+      nsTObserverArray<nsIMutationObserver*>::ForwardIterator iter_ =
+        slots->mMutationObservers;
+      nsCOMPtr<nsIMutationObserver2> obs_;
+      while (iter_.HasMore()) {
+        obs_ = do_QueryInterface(iter_.GetNext());
+        if (obs_) {
+          obs_->AttributeChildRemoved(aAttribute, aChild);
+        }
+      }
+    }
+    aAttribute = aAttribute->GetNodeParent();
+  } while (aAttribute);
+}
+
+void
 nsNodeUtils::ParentChainChanged(nsIContent *aContent)
 {
   // No need to notify observers on the parents since their parent
   // chain must have been changed too and so their observers were
   // notified at that time.
 
   nsINode::nsSlots* slots = aContent->GetExistingSlots();
   if (slots && !slots->mMutationObservers.IsEmpty()) {
diff --git a/content/base/src/nsNodeUtils.h b/content/base/src/nsNodeUtils.h
--- a/content/base/src/nsNodeUtils.h
+++ b/content/base/src/nsNodeUtils.h
@@ -125,16 +125,25 @@ public:
    * @param aContainer        Node from which child was removed
    * @param aChild            Removed child
    * @param aIndexInContainer Index of removed child
    * @see nsIMutationObserver::ContentRemoved
    */
   static void ContentRemoved(nsINode* aContainer,
                              nsIContent* aChild,
                              PRInt32 aIndexInContainer);
+
+  /**
+   * Send AttributeChildRemoved notifications to nsIMutationObservers.
+   * @param aAttribute Attribute from which the child has been removed.
+   * @param aChild     Removed child.
+   * @see nsIMutationObserver2::AttributeChildRemoved.
+   */
+  static void AttributeChildRemoved(nsINode* aAttribute, nsIContent* aChild);
+
   /**
    * Send ParentChainChanged notifications to nsIMutationObservers
    * @param aContent  The piece of content that had its parent changed.
    * @see nsIMutationObserver::ParentChainChanged
    */
   static void ParentChainChanged(nsIContent *aContent);
 
   /**
diff --git a/content/base/src/nsStubMutationObserver.cpp b/content/base/src/nsStubMutationObserver.cpp
--- a/content/base/src/nsStubMutationObserver.cpp
+++ b/content/base/src/nsStubMutationObserver.cpp
@@ -41,8 +41,11 @@
  * used as a base class within the content/layout library.  All methods do
  * nothing.
  */
 
 #include "nsStubMutationObserver.h"
 
 NS_IMPL_NSIMUTATIONOBSERVER_CORE_STUB(nsStubMutationObserver)
 NS_IMPL_NSIMUTATIONOBSERVER_CONTENT(nsStubMutationObserver)
+
+NS_IMPL_NSIMUTATIONOBSERVER_CORE_STUB(nsStubMutationObserver2)
+NS_IMPL_NSIMUTATIONOBSERVER2_CONTENT(nsStubMutationObserver2)
diff --git a/content/base/src/nsStubMutationObserver.h b/content/base/src/nsStubMutationObserver.h
--- a/content/base/src/nsStubMutationObserver.h
+++ b/content/base/src/nsStubMutationObserver.h
@@ -41,25 +41,30 @@
  * used as a base class within the content/layout library.  All methods do
  * nothing.
  */
 
 #ifndef nsStubMutationObserver_h_
 #define nsStubMutationObserver_h_
 
 #include "nsIMutationObserver.h"
+#include "nsIMutationObserver2.h"
 
 /**
  * There are two advantages to inheriting from nsStubMutationObserver
  * rather than directly from nsIMutationObserver:
  *  1. smaller compiled code size (since there's no need for the code
  *     for the empty virtual function implementations for every
  *     nsIMutationObserver implementation)
  *  2. the performance of document's loop over observers benefits from
  *     the fact that more of the functions called are the same (which
  *     can reduce instruction cache misses and perhaps improve branch
  *     prediction)
  */
 class nsStubMutationObserver : public nsIMutationObserver {
   NS_DECL_NSIMUTATIONOBSERVER
 };
 
+class nsStubMutationObserver2 : public nsIMutationObserver2 {
+  NS_DECL_NSIMUTATIONOBSERVER2
+};
+
 #endif /* !defined(nsStubMutationObserver_h_) */
