diff --git a/widget/src/windows/nsWindow.cpp b/widget/src/windows/nsWindow.cpp
--- a/widget/src/windows/nsWindow.cpp
+++ b/widget/src/windows/nsWindow.cpp
@@ -740,17 +740,17 @@ nsWindow::nsWindow() : nsBaseWidget()
   mPaintDC            = 0;
   mPrevWndProc        = NULL;
   mBackground         = ::GetSysColor(COLOR_BTNFACE);
   mBrush              = ::CreateSolidBrush(NSRGB_2_COLOREF(mBackground));
   mForeground         = ::GetSysColor(COLOR_WINDOWTEXT);
   mIsShiftDown        = PR_FALSE;
   mIsControlDown      = PR_FALSE;
   mIsAltDown          = PR_FALSE;
-  mIsDestroying       = PR_FALSE;
+  mInDtor             = PR_FALSE;
   mDeferredPositioner = NULL;
   mLastPoint.x        = 0;
   mLastPoint.y        = 0;
   mPreferredWidth     = 0;
   mPreferredHeight    = 0;
   mIsVisible          = PR_FALSE;
   mHas3DBorder        = PR_FALSE;
 #ifdef MOZ_XUL
@@ -805,40 +805,22 @@ nsWindow::nsWindow() : nsBaseWidget()
 
 //-------------------------------------------------------------------------
 //
 // nsWindow destructor
 //
 //-------------------------------------------------------------------------
 nsWindow::~nsWindow()
 {
-  mIsDestroying = PR_TRUE;
-  if (gCurrentWindow == this) {
-    gCurrentWindow = nsnull;
-  }
-
-  MouseTrailer* mtrailer = nsToolkit::gMouseTrailer;
-  if (mtrailer) {
-    if (mtrailer->GetMouseTrailerWindow() == mWnd)
-      mtrailer->DestroyTimer();
-
-    if (mtrailer->GetCaptureWindow() == mWnd)
-      mtrailer->SetCaptureWindow(nsnull);
-  }
+  mInDtor = PR_TRUE;
 
   // If the widget was released without calling Destroy() then the native
   // window still exists, and we need to destroy it
-  if (NULL != mWnd) {
+  if (NULL != mWnd)
     Destroy();
-  }
-
-  if (mCursor == -1) {
-    // A successfull SetCursor call will destroy the custom cursor, if it's ours
-    SetCursor(eCursor_standard);
-  }
 
 #ifndef WINCE
   //
   // delete any of the IME structures that we allocated
   //
   sInstanceCount--;
   if (sInstanceCount == 0) {
     if (sIMECompUnicode) 
@@ -1245,17 +1227,17 @@ LRESULT CALLBACK nsWindow::WindowProc(HW
     NS_ASSERTION(someWindow, "someWindow is null, cannot call any CallWindowProc");
     return ::DefWindowProcW(hWnd, msg, wParam, lParam);
   }
 
   // hold on to the window for the life of this method, in case it gets
   // deleted during processing. yes, it's a double hack, since someWindow
   // is not really an interface.
   nsCOMPtr<nsISupports> kungFuDeathGrip;
-  if (!someWindow->mIsDestroying) // not if we're in the destructor!
+  if (!someWindow->mInDtor) // not if we're in the destructor!
     kungFuDeathGrip = do_QueryInterface((nsBaseWidget*)someWindow);
 
   // Re-direct a tab change message destined for its parent window to the
   // the actual window which generated the event.
   if (msg == WM_NOTIFY) {
     LPNMHDR pnmh = (LPNMHDR) lParam;
     if (pnmh->code == TCN_SELCHANGE) {
       someWindow = GetNSWindowPtr(pnmh->hwndFrom);
@@ -1511,83 +1493,51 @@ NS_METHOD nsWindow::Create(nsNativeWidge
 }
 
 
 //-------------------------------------------------------------------------
 //
 // Close this nsWindow
 //
 //-------------------------------------------------------------------------
+// Close this nsWindow
 NS_METHOD nsWindow::Destroy()
 {
-  // Switch to the "main gui thread" if necessary... This method must
-  // be executed on the "gui thread"...
+  // WM_DESTROY has already fired, we're done.
+  if (nsnull == mWnd)
+    return NS_OK;
+
+  // Switch to the "main gui thread" if necessary. Destroy() must be executed on the
+  // "gui thread".
   nsToolkit* toolkit = (nsToolkit *)mToolkit;
   if (toolkit != nsnull && !toolkit->IsGuiThread()) {
     MethodInfo info(this, nsWindow::DESTROY);
     toolkit->CallMethod(&info);
     return NS_ERROR_FAILURE;
   }
 
-  // disconnect from the parent
-  if (!mIsDestroying) {
-    nsBaseWidget::Destroy();
-  }
-
-  // just to be safe. If we're going away and for some reason we're still
-  // the rollup widget, rollup and turn off capture.
-  if ( this == gRollupWidget ) {
-    if ( gRollupListener )
-      gRollupListener->Rollup(nsnull);
-    CaptureRollupEvents(nsnull, PR_FALSE, PR_TRUE);
-  }
-
-  EnableDragDrop(PR_FALSE);
-
-  // destroy the HWND
-  if (mWnd) {
-    // prevent the widget from causing additional events
-    mEventCallback = nsnull;
-    if (gAttentionTimerMonitor)
-      gAttentionTimerMonitor->KillTimer(mWnd);
-
-    // if IME is disabled, restore it.
-    if (mOldIMC) {
-      mOldIMC = ::ImmAssociateContext(mWnd, mOldIMC);
-      NS_ASSERTION(!mOldIMC, "Another IMC was associated");
-    }
-
-    HICON icon;
-    icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_BIG, (LPARAM) 0);
-    if (icon)
-      ::DestroyIcon(icon);
-
-    icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM) 0);
-    if (icon)
-      ::DestroyIcon(icon);
-
-#ifdef MOZ_XUL
-    if (eTransparencyTransparent == mTransparencyMode)
-    {
-      SetupTranslucentWindowMemoryBitmap(eTransparencyOpaque);
-
-    }
-#endif
-
-    VERIFY(::DestroyWindow(mWnd));
-
-    mWnd = NULL;
-    //our windows can be subclassed by
-    //others and these nameless, faceless others
-    //may not let us know about WM_DESTROY. so,
-    //if OnDestroy() didn't get called, just call
-    //it now. MMP
-    if (PR_FALSE == mOnDestroyCalled)
-      OnDestroy();
-  }
+  // During the destruction of all of our children, make sure we don't get deleted.
+  nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
+
+  // The DestroyWindow function destroys the specified window. The function sends WM_DESTROY
+  // and WM_NCDESTROY messages to the window to deactivate it and remove the keyboard focus
+  // from it. The function also destroys the window's menu, flushes the thread message queue,
+  // destroys timers, removes clipboard ownership, and breaks the clipboard viewer chain (if
+  // the window is at the top of the viewer chain).
+  //
+  // If the specified window is a parent or owner window, DestroyWindow automatically destroys
+  // the associated child or owned windows when it destroys the parent or owner window. The
+  // function first destroys child or owned windows, and then it destroys the parent or owner
+  // window.
+  VERIFY(::DestroyWindow(mWnd));
+  
+  // Our windows can be subclassed which may prevent us receiving WM_DESTROY. If OnDestroy()
+  // didn't get called, call it now.
+  if (PR_FALSE == mOnDestroyCalled)
+    OnDestroy();
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsWindow::SetParent(nsIWidget *aNewParent)
 {
   if (aNewParent) {
     nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
@@ -1612,17 +1562,18 @@ NS_IMETHODIMP nsWindow::SetParent(nsIWid
 
   nsIWidget* parent = GetParent();
 
   if (parent) {
     parent->RemoveChild(this);
   }
 
   if (mWnd) {
-    ::SetParent(mWnd, nsnull);
+    // If we have no parent, SetParent should return the desktop.
+    VERIFY(::SetParent(mWnd, nsnull));
   }
 
   return NS_OK;
 }
 
 
 //-------------------------------------------------------------------------
 //
@@ -1641,17 +1592,17 @@ nsWindow* nsWindow::GetParentWindow(PRBo
     // owned by the topmost widget, because a child window can be embedded inside
     // a HWND which is not associated with a nsIWidget.
     return nsnull;
   }
 
   // If this widget has already been destroyed, pretend we have no parent.
   // This corresponds to code in Destroy which removes the destroyed
   // widget from its parent's child list.
-  if (mIsDestroying || mOnDestroyCalled)
+  if (mInDtor || mOnDestroyCalled)
     return nsnull;
 
 
   // aIncludeOwner set to true implies walking the parent chain to retrieve the
   // root owner. aIncludeOwner set to false implies the search will stop at the
   // true parent (default).
   nsWindow* widget = nsnull;
   if (mWnd) {
@@ -1660,17 +1611,17 @@ nsWindow* nsWindow::GetParentWindow(PRBo
       parent = ::GetParent(mWnd);
     else
       parent = ::GetAncestor(mWnd, GA_PARENT);
     if (parent) {
       widget = GetNSWindowPtr(parent);
       if (widget) {
         // If the widget is in the process of being destroyed then
         // do NOT return it
-        if (widget->mIsDestroying) {
+        if (widget->mInDtor) {
           widget = nsnull;
         }
       }
     }
   }
 
   return widget;
 }
@@ -6000,66 +5951,131 @@ void nsWindow::SubclassWindow(BOOL bStat
       else
         ::SetWindowLongA(mWnd, GWL_WNDPROC, (LONG)mPrevWndProc);
       SetNSWindowPtr(mWnd, NULL);
       mPrevWndProc = NULL;
     }
   }
 }
 
+/*
+nsTraceRefcntImpl::DumpStatistics: 988 entries
+TEST-UNEXPECTED-FAIL | runtests-leaks | leaked 484 bytes during test execution
+TEST-UNEXPECTED-FAIL | runtests-leaks | leaked 1 instance of nsComponentManagerImpl with size 276 bytes
+TEST-UNEXPECTED-FAIL | runtests-leaks | leaked 2 instances of nsLocalFile with size 88 bytes each (176 bytes total)
+TEST-UNEXPECTED-FAIL | runtests-leaks | leaked 3 instances of nsStringBuffer with size 8 bytes each (24 bytes total)
+TEST-UNEXPECTED-FAIL | runtests-leaks | leaked 2 instances of nsTArray_base with size 4 bytes each (8 bytes total)
+*/
 
 //-------------------------------------------------------------------------
 //
 // WM_DESTROY has been called
 //
 //-------------------------------------------------------------------------
+// WM_DESTROY event handler
 void nsWindow::OnDestroy()
 {
   mOnDestroyCalled = PR_TRUE;
 
+  // Make sure we don't get destroyed in the process of tearing down.
+  nsCOMPtr<nsIWidget> kungFuDeathGrip(this);
+  
+  // Dispatch the NS_DESTROY event. Must be called before mEventCallback is cleared.
+  if (!mInDtor)
+    DispatchStandardEvent(NS_DESTROY);
+
+  // Prevent the widget from sending additional events.
+  mEventCallback = nsnull;
+
+  // Free our subclass and clear |this| stored in the window props. We will no longer
+  // receive events from Windows after this point.
   SubclassWindow(FALSE);
 
-  // We have to destroy the native drag target before we null out our
-  // window pointer
+  // Once mEventCallback is cleared and the subclass is reset, gCurrentWindow can be
+  // cleared. (It's used in tracking windows for mouse events.)
+  if (gCurrentWindow == this)
+    gCurrentWindow = nsnull;
+
+  // Disconnects us from our parent, will call our GetParent().
+  nsBaseWidget::Destroy();
+
+  // Release references to children, device context, toolkit, and app shell.
+  nsBaseWidget::OnDestroy();
+  
+  // Clear our native parent handle.
+  // XXX Windows will take care of this in the proper order, and SetParent(nsnull)'s
+  // remove child on the parent already took place in nsBaseWidget's Destroy call above.
+  //SetParent(nsnull);
+
+  // We have to destroy the native drag target before we null out our window pointer.
   EnableDragDrop(PR_FALSE);
 
-  mWnd = NULL;
-
-  // free GDI objects
+  // If we're going away and for some reason we're still the rollup widget, rollup and
+  // turn off capture.
+  if ( this == gRollupWidget ) {
+    if ( gRollupListener )
+      gRollupListener->Rollup(nsnull);
+    CaptureRollupEvents(nsnull, PR_FALSE, PR_TRUE);
+  }
+
+  // Destroy the flash window timer if it exists.
+  if (gAttentionTimerMonitor)
+    gAttentionTimerMonitor->KillTimer(mWnd);
+  
+  // If IME is disabled, restore it.
+  if (mOldIMC) {
+    mOldIMC = ::ImmAssociateContext(mWnd, mOldIMC);
+    NS_ASSERTION(!mOldIMC, "Another IMC was associated");
+  }
+
+  // Turn off mouse trails if enabled.
+  MouseTrailer* mtrailer = nsToolkit::gMouseTrailer;
+  if (mtrailer) {
+    if (mtrailer->GetMouseTrailerWindow() == mWnd)
+      mtrailer->DestroyTimer();
+
+    if (mtrailer->GetCaptureWindow() == mWnd)
+      mtrailer->SetCaptureWindow(nsnull);
+  }
+
+  // If we were in the middle of deferred window positioning then free the memory for the
+  // multiple-window position structure.
+  if (mDeferredPositioner) {
+    VERIFY(::EndDeferWindowPos(mDeferredPositioner));
+    mDeferredPositioner = NULL;
+  }
+
+  // Free GDI window class objects
   if (mBrush) {
     VERIFY(::DeleteObject(mBrush));
     mBrush = NULL;
   }
 
-#if 0
-  if (mPalette) {
-    VERIFY(::DeleteObject(mPalette));
-    mPalette = NULL;
-  }
-#endif
-
-  // if we were in the middle of deferred window positioning then
-  // free the memory for the multiple-window position structure
-  if (mDeferredPositioner) {
-    VERIFY(::EndDeferWindowPos(mDeferredPositioner));
-    mDeferredPositioner = NULL;
-  }
-
-  // release references to children, device context, toolkit, and app shell
-  nsBaseWidget::OnDestroy();
-
-  // dispatch the event
-  if (!mIsDestroying) {
-    // dispatching of the event may cause the reference count to drop to 0
-    // and result in this object being destroyed. To avoid that, add a reference
-    // and then release it after dispatching the event
-    AddRef();
-    DispatchStandardEvent(NS_DESTROY);
-    Release();
-  }
+  // Free app icon resources.
+  HICON icon;
+  icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_BIG, (LPARAM) 0);
+  if (icon)
+    ::DestroyIcon(icon);
+
+  icon = (HICON) ::SendMessageW(mWnd, WM_SETICON, (WPARAM)ICON_SMALL, (LPARAM) 0);
+  if (icon)
+    ::DestroyIcon(icon);
+
+  // Destroy any custom cursor resources.
+  if (mCursor == -1)
+    SetCursor(eCursor_standard);
+
+#ifdef MOZ_XUL
+  // Reset transparency
+  if (eTransparencyTransparent == mTransparencyMode)
+    SetupTranslucentWindowMemoryBitmap(eTransparencyOpaque);
+#endif
+
+  // Clear the main HWND.
+  mWnd = NULL;
 }
 
 //-------------------------------------------------------------------------
 //
 // Move
 //
 //-------------------------------------------------------------------------
 PRBool nsWindow::OnMove(PRInt32 aX, PRInt32 aY)
@@ -6580,22 +6596,22 @@ PRBool nsWindow::DispatchMouseEvent(PRUi
       }
       nsRect rect;
       GetBounds(rect);
       rect.x = 0;
       rect.y = 0;
 
       if (rect.Contains(event.refPoint)) {
         if (gCurrentWindow == NULL || gCurrentWindow != this) {
-          if ((nsnull != gCurrentWindow) && (!gCurrentWindow->mIsDestroying)) {
+          if ((nsnull != gCurrentWindow) && (!gCurrentWindow->mInDtor)) {
             LPARAM pos = gCurrentWindow->lParamToClient(lParamToScreen(lParam));
             gCurrentWindow->DispatchMouseEvent(NS_MOUSE_EXIT, wParam, pos);
           }
           gCurrentWindow = this;
-          if (!mIsDestroying) {
+          if (!mInDtor) {
             LPARAM pos = gCurrentWindow->lParamToClient(lParamToScreen(lParam));
             gCurrentWindow->DispatchMouseEvent(NS_MOUSE_ENTER, wParam, pos);
           }
         }
       }
     } else if (aEventType == NS_MOUSE_EXIT) {
       if (gCurrentWindow == this) {
         gCurrentWindow = nsnull;
@@ -8469,17 +8485,17 @@ nsWindow :: DealWithPopups ( HWND inWnd,
 
 
 
 #ifdef ACCESSIBILITY
 already_AddRefed<nsIAccessible> nsWindow::GetRootAccessible()
 {
   nsWindow::gIsAccessibilityOn = TRUE;
 
-  if (mIsDestroying || mOnDestroyCalled || mWindowType == eWindowType_invisible) {
+  if (mInDtor || mOnDestroyCalled || mWindowType == eWindowType_invisible) {
     return nsnull;
   }
 
   nsIAccessible *rootAccessible = nsnull;
 
   // If accessibility is turned on, we create this even before it is requested
   // when the window gets focused. We need it to be created early so it can 
   // generate accessibility events right away
diff --git a/widget/src/windows/nsWindow.h b/widget/src/windows/nsWindow.h
--- a/widget/src/windows/nsWindow.h
+++ b/widget/src/windows/nsWindow.h
@@ -491,17 +491,17 @@ protected:
   HDC           mMemoryDC;
   nsTransparencyMode mTransparencyMode;
 #endif
   PRPackedBool  mIsTopWidgetWindow;
   PRPackedBool  mHas3DBorder;
   PRPackedBool  mIsShiftDown;
   PRPackedBool  mIsControlDown;
   PRPackedBool  mIsAltDown;
-  PRPackedBool  mIsDestroying;
+  PRPackedBool  mInDtor;
   PRPackedBool  mIsVisible;
   PRPackedBool  mIsInMouseCapture;
   PRPackedBool  mIsInMouseWheelProcessing;
   PRPackedBool  mUnicodeWidget;
   PRPackedBool  mIsPluginWindow;
 
   PRPackedBool  mPainting;
   char          mLeadByte;
