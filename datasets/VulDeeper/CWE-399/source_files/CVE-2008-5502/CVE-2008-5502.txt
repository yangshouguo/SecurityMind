diff
--- 31-ff.orig/js/src/jsscan.cpp	2008-10-06 13:45:09.000000000 +0200
+++ 31-ff/js/src/jsscan.cpp	2008-10-06 13:53:30.000000000 +0200
@@ -809,23 +809,27 @@ GetXMLEntity(JSContext *cx, JSTokenStrea
     JSBool ispair;
     jschar *bp, digit;
     char *bytes;
     JSErrNum msg;
 
     /* Put the entity, including the '&' already scanned, in ts->tokenbuf. */
     offset = PTRDIFF(ts->tokenbuf.ptr, ts->tokenbuf.base, jschar);
     FastAppendChar(&ts->tokenbuf, '&');
+    if (!STRING_BUFFER_OK(&ts->tokenbuf))
+        return JS_FALSE;
     while ((c = GetChar(ts)) != ';') {
         if (c == EOF || c == '\n') {
             js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
                                         JSMSG_END_OF_XML_ENTITY);
             return JS_FALSE;
         }
         FastAppendChar(&ts->tokenbuf, (jschar) c);
+        if (!STRING_BUFFER_OK(&ts->tokenbuf))
+            return JS_FALSE;
     }
 
     /* Let length be the number of jschars after the '&', including the ';'. */
     length = PTRDIFF(ts->tokenbuf.ptr, ts->tokenbuf.base, jschar) - offset;
     bp = ts->tokenbuf.base + offset;
     c = d = 0;
     ispair = JS_FALSE;
     if (length > 2 && bp[1] == '#') {
@@ -901,16 +905,18 @@ GetXMLEntity(JSContext *cx, JSTokenStrea
     *bp = 0;
     ts->tokenbuf.ptr = bp;
     return JS_TRUE;
 
 badncr:
     msg = JSMSG_BAD_XML_NCR;
 bad:
     /* No match: throw a TypeError per ECMA-357 10.3.2.1 step 8(a). */
+    JS_ASSERT(STRING_BUFFER_OK(&ts->tokenbuf));
+    JS_ASSERT(PTRDIFF(ts->tokenbuf.ptr, bp, jschar) >= 1);
     bytes = js_DeflateString(cx, bp + 1,
                              PTRDIFF(ts->tokenbuf.ptr, bp, jschar) - 1);
     if (bytes) {
         js_ReportCompileErrorNumber(cx, ts, NULL, JSREPORT_ERROR,
                                     msg, bytes);
         JS_free(cx, bytes);
     }
     return JS_FALSE;
