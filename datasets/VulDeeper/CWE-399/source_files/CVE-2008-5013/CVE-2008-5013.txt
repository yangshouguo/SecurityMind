diff -u -9 -p -r1.127.2.8 ns4xPlugin.cpp
--- a/modules/plugin/base/src/ns4xPlugin.cpp	28 Jan 2007 19:44:05 -0000	1.127.2.8
+++ b/modules/plugin/base/src/ns4xPlugin.cpp	26 Aug 2008 03:59:02 -0000
@@ -1066,18 +1066,20 @@ NPError
 MakeNew4xStreamInternal(NPP npp, const char *relativeURL, const char *target,
                         eNPPStreamTypeInternal type,
                         PRBool bDoNotify = PR_FALSE,
                         void *notifyData = nsnull, uint32 len = 0,
                         const char *buf = nsnull, NPBool file = PR_FALSE)
 {
   if (!npp)
     return NPERR_INVALID_INSTANCE_ERROR;
 
+  PluginDestructionGuard guard(npp);
+
   nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
 
   NS_ASSERTION(inst != NULL, "null instance");
   if (inst == NULL)
     return NPERR_INVALID_INSTANCE_ERROR;
 
   nsCOMPtr<nsIPluginManager> pm = do_GetService(kPluginManagerCID);
   NS_ASSERTION(pm, "failed to get plugin manager");
   if (!pm) return NPERR_GENERIC_ERROR;
@@ -1114,18 +1116,20 @@ MakeNew4xStreamInternal(NPP npp, const c
 //
 
 NPError NP_EXPORT
 _geturl(NPP npp, const char* relativeURL, const char* target)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
   ("NPN_GetURL: npp=%p, target=%s, url=%s\n", (void *)npp, target,
    relativeURL));
 
+  PluginDestructionGuard guard(npp);
+
   // Block Adobe Acrobat from loading URLs that are not http:, https:,
   // or ftp: URLs if the given target is null.
   if (target == nsnull && relativeURL &&
       (strncmp(relativeURL, "http:", 5) != 0) &&
       (strncmp(relativeURL, "https:", 6) != 0) &&
       (strncmp(relativeURL, "ftp:", 4) != 0)) {
     ns4xPluginInstance *inst = (ns4xPluginInstance *) npp->ndata;
 
     const char *name = nsPluginHostImpl::GetPluginName(inst);
@@ -1143,54 +1147,60 @@ _geturl(NPP npp, const char* relativeURL
 ////////////////////////////////////////////////////////////////////////
 NPError NP_EXPORT
 _geturlnotify(NPP npp, const char* relativeURL, const char* target,
               void* notifyData)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
     ("NPN_GetURLNotify: npp=%p, target=%s, notify=%p, url=%s\n", (void*)npp,
      target, notifyData, relativeURL));
 
+  PluginDestructionGuard guard(npp);
+
   return MakeNew4xStreamInternal (npp, relativeURL, target,
                                   eNPPStreamTypeInternal_Get, PR_TRUE,
                                   notifyData);
 }
 
 
 ////////////////////////////////////////////////////////////////////////
 NPError NP_EXPORT
 _posturlnotify(NPP npp, const char *relativeURL, const char *target,
                uint32 len, const char *buf, NPBool file, void *notifyData)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                  ("NPN_PostURLNotify: npp=%p, target=%s, len=%d, file=%d, "
                   "notify=%p, url=%s, buf=%s\n",
                   (void*)npp, target, len, file, notifyData, relativeURL,
                   buf));
 
+  PluginDestructionGuard guard(npp);
+
   return MakeNew4xStreamInternal(npp, relativeURL, target,
                                  eNPPStreamTypeInternal_Post, PR_TRUE,
                                  notifyData, len, buf, file);
 }
 
 
 ////////////////////////////////////////////////////////////////////////
 NPError NP_EXPORT
 _posturl(NPP npp, const char *relativeURL, const char *target,
          uint32 len, const char *buf, NPBool file)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                  ("NPN_PostURL: npp=%p, target=%s, file=%d, len=%d, url=%s, "
                   "buf=%s\n",
                   (void*)npp, target, file, len, relativeURL, buf));
 
- return MakeNew4xStreamInternal(npp, relativeURL, target,
-                                eNPPStreamTypeInternal_Post, PR_FALSE, nsnull,
-                                len, buf, file);
+  PluginDestructionGuard guard(npp);
+
+  return MakeNew4xStreamInternal(npp, relativeURL, target,
+                                 eNPPStreamTypeInternal_Post, PR_FALSE, nsnull,
+                                 len, buf, file);
 }
 
 
 ////////////////////////////////////////////////////////////////////////
 // A little helper class used to wrap up plugin manager streams (that is,
 // streams from the plugin to the browser).
 
 class ns4xStreamWrapper : nsISupports
 {
@@ -1242,18 +1252,21 @@ NPError NP_EXPORT
 _newstream(NPP npp, NPMIMEType type, const char* target, NPStream* *result)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
   ("NPN_NewStream: npp=%p, type=%s, target=%s\n", (void*)npp,
    (const char *)type, target));
 
   NPError err = NPERR_INVALID_INSTANCE_ERROR;
   if (npp && npp->ndata) {
     nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
+
+    PluginDestructionGuard guard(inst);
+
     nsCOMPtr<nsIOutputStream> stream;
     nsCOMPtr<nsIPluginInstancePeer> peer;
     if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) &&
       peer &&
       NS_SUCCEEDED(peer->NewStream((const char*) type, target,
                                    getter_AddRefs(stream)))) {
       ns4xStreamWrapper* wrapper = new ns4xStreamWrapper(stream);
       if (wrapper) {
         (*result) = wrapper->GetNPStream();
@@ -1275,18 +1288,20 @@ _write(NPP npp, NPStream *pstream, int32
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                  ("NPN_Write: npp=%p, url=%s, len=%d, buffer=%s\n", (void*)npp,
                   pstream->url, len, (char*)buffer));
 
   // negative return indicates failure to the plugin
   if (!npp)
     return -1;
 
+  PluginDestructionGuard guard(npp);
+
   ns4xStreamWrapper* wrapper = (ns4xStreamWrapper*) pstream->ndata;
   NS_ASSERTION(wrapper != NULL, "null stream");
 
   if (wrapper == NULL)
     return -1;
 
   nsIOutputStream* stream;
   wrapper->GetStream(stream);
 
@@ -1306,18 +1321,20 @@ NPError NP_EXPORT
 _destroystream(NPP npp, NPStream *pstream, NPError reason)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
                  ("NPN_DestroyStream: npp=%p, url=%s, reason=%d\n", (void*)npp,
                   pstream->url, (int)reason));
 
   if (!npp)
     return NPERR_INVALID_INSTANCE_ERROR;
 
+  PluginDestructionGuard guard(npp);
+
   nsCOMPtr<nsIPluginStreamListener> listener =
     do_QueryInterface((nsISupports *)pstream->ndata);
 
   // DestroyStream can kill two kinds of streams: NPP derived and NPN derived.
   // check to see if they're trying to kill a NPP stream
   if (listener) {
     // Tell the stream listner that the stream is now gone.
     listener->OnStopBinding(nsnull, NS_BINDING_ABORTED);
 
@@ -1350,18 +1367,20 @@ _status(NPP npp, const char *message)
                                      (void*)npp, message));
 
   if (!npp || !npp->ndata) {
     NS_WARNING("_status: npp or npp->ndata == 0");
     return;
   }
 
   nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
 
+  PluginDestructionGuard guard(inst);
+
   nsCOMPtr<nsIPluginInstancePeer> peer;
   if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
     peer->ShowStatus(message);
   }
 }
 
 
 ////////////////////////////////////////////////////////////////////////
 void NP_EXPORT
@@ -1408,18 +1427,20 @@ _invalidaterect(NPP npp, NPRect *invalid
                   invalidRect->left, invalidRect->bottom, invalidRect->right));
 
   if (!npp || !npp->ndata) {
     NS_WARNING("_invalidaterect: npp or npp->ndata == 0");
     return;
   }
 
   nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
 
+  PluginDestructionGuard guard(inst);
+
   nsCOMPtr<nsIPluginInstancePeer> peer;
   if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
     nsCOMPtr<nsIWindowlessPluginInstancePeer> wpeer(do_QueryInterface(peer));
     if (wpeer) {
       // XXX nsRect & NPRect are structurally equivalent
       wpeer->InvalidateRect((nsPluginRect *)invalidRect);
     }
   }
 }
@@ -1434,18 +1455,20 @@ _invalidateregion(NPP npp, NPRegion inva
                   (void*)invalidRegion));
 
   if (!npp || !npp->ndata) {
     NS_WARNING("_invalidateregion: npp or npp->ndata == 0");
     return;
   }
 
   nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
 
+  PluginDestructionGuard guard(inst);
+
   nsCOMPtr<nsIPluginInstancePeer> peer;
   if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
     nsCOMPtr<nsIWindowlessPluginInstancePeer> wpeer(do_QueryInterface(peer));
     if (wpeer) {
       // XXX nsRegion & NPRegion are typedef'd to the same thing
       wpeer->InvalidateRegion((nsPluginRegion)invalidRegion);
     }
   }
 }
@@ -1458,35 +1481,39 @@ _forceredraw(NPP npp)
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_ForceDraw: npp=%p\n", (void*)npp));
 
   if (!npp || !npp->ndata) {
     NS_WARNING("_forceredraw: npp or npp->ndata == 0");
     return;
   }
 
   nsIPluginInstance *inst = (nsIPluginInstance *) npp->ndata;
 
+  PluginDestructionGuard guard(inst);
+
   nsCOMPtr<nsIPluginInstancePeer> peer;
   if (NS_SUCCEEDED(inst->GetPeer(getter_AddRefs(peer))) && peer) {
     nsCOMPtr<nsIWindowlessPluginInstancePeer> wpeer(do_QueryInterface(peer));
     if (wpeer) {
       wpeer->ForceRedraw();
     }
   }
 }
 
 static JSContext *
 GetJSContextFromNPP(NPP npp)
 {
   NS_ENSURE_TRUE(npp, nsnull);
 
   ns4xPluginInstance *inst = (ns4xPluginInstance *)npp->ndata;
   NS_ENSURE_TRUE(inst, nsnull);
 
+  PluginDestructionGuard guard(inst);
+
   nsCOMPtr<nsIPluginInstancePeer> pip;
   inst->GetPeer(getter_AddRefs(pip));
   nsCOMPtr<nsPIPluginInstancePeer> pp(do_QueryInterface(pip));
   NS_ENSURE_TRUE(pp, nsnull);
 
   nsCOMPtr<nsIPluginInstanceOwner> owner;
   pp->GetOwner(getter_AddRefs(owner));
   NS_ENSURE_TRUE(owner, nsnull);
 
@@ -1645,18 +1672,20 @@ _identifierisstring(NPIdentifier identif
 NPObject* NP_EXPORT
 _createobject(NPP npp, NPClass* aClass)
 {
   if (!npp) {
     NS_ERROR("Null npp passed to _createobject()!");
 
     return nsnull;
   }
 
+  PluginDestructionGuard guard(npp);
+
   if (!aClass) {
     NS_ERROR("Null class passed to _createobject()!");
 
     return nsnull;
   }
 
   NPPAutoPusher nppPusher(npp);
 
   NPObject *npobj;
@@ -1666,18 +1695,21 @@ _createobject(NPP npp, NPClass* aClass)
   } else {
     npobj = (NPObject *)PR_Malloc(sizeof(NPObject));
   }
 
   if (npobj) {
     npobj->_class = aClass;
     npobj->referenceCount = 1;
   }
 
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("Created NPObject %p, NPClass %p\n", npobj, aClass));
+
   return npobj;
 }
 
 NPObject* NP_EXPORT
 _retainobject(NPObject* npobj)
 {
   if (npobj) {
     PR_AtomicIncrement((PRInt32*)&npobj->referenceCount);
   }
@@ -1703,34 +1735,44 @@ _releaseobject(NPObject* npobj)
 }
 
 bool NP_EXPORT
 _invoke(NPP npp, NPObject* npobj, NPIdentifier method, const NPVariant *args,
         uint32_t argCount, NPVariant *result)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->invoke)
     return false;
 
+  PluginDestructionGuard guard(npp);
+
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("NPN_Invoke(npp %p, npobj %p, method %p, args %d\n", npp,
+                  npobj, method, argCount));
+
   return npobj->_class->invoke(npobj, method, args, argCount, result);
 }
 
 bool NP_EXPORT
 _invokeDefault(NPP npp, NPObject* npobj, const NPVariant *args,
                uint32_t argCount, NPVariant *result)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->invokeDefault)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("NPN_InvokeDefault(npp %p, npobj %p, args %d\n", npp,
+                  npobj, argCount));
+
   return npobj->_class->invokeDefault(npobj, args, argCount, result);
 }
 
 bool NP_EXPORT
 _evaluate(NPP npp, NPObject* npobj, NPString *script, NPVariant *result)
 {
   if (!npp)
     return false;
 
@@ -1765,84 +1807,108 @@ _evaluate(NPP npp, NPObject* npobj, NPSt
   NS_ConvertUTF8toUTF16 utf16script(script->utf8characters,
                                     script->utf8length);
 
   nsCOMPtr<nsIScriptContext> scx = GetScriptContextFromJSContext(cx);
   NS_ENSURE_TRUE(scx, false);
 
   nsIPrincipal *principal = nsnull;
   // XXX: Get the principal from the security stack (TBD)
 
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("NPN_Evaluate(npp %p, npobj %p, script <<<%s>>>) called\n",
+                  npp, npobj, script->utf8characters));
+
   nsresult rv = scx->EvaluateStringWithValue(utf16script, obj, principal,
                                              nsnull, 0, nsnull, rval, nsnull);
 
   return NS_SUCCEEDED(rv) &&
          (!result || JSValToNPVariant(npp, cx, *rval, result));
 }
 
 bool NP_EXPORT
 _getproperty(NPP npp, NPObject* npobj, NPIdentifier property,
              NPVariant *result)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->getProperty)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("NPN_GetProperty(npp %p, npobj %p, property %p) called\n",
+                  npp, npobj, property));
+
   return npobj->_class->getProperty(npobj, property, result);
 }
 
 bool NP_EXPORT
 _setproperty(NPP npp, NPObject* npobj, NPIdentifier property,
              const NPVariant *value)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->setProperty)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("NPN_SetProperty(npp %p, npobj %p, property %p) called\n",
+                  npp, npobj, property));
+
   return npobj->_class->setProperty(npobj, property, value);
 }
 
 bool NP_EXPORT
 _removeproperty(NPP npp, NPObject* npobj, NPIdentifier property)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->removeProperty)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("NPN_RemoveProperty(npp %p, npobj %p, property %p) called\n",
+                  npp, npobj, property));
+
   return npobj->_class->removeProperty(npobj, property);
 }
 
 bool NP_EXPORT
 _hasproperty(NPP npp, NPObject* npobj, NPIdentifier propertyName)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->hasProperty)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("NPN_HasProperty(npp %p, npobj %p, property %p) called\n",
+                  npp, npobj, propertyName));
+
   return npobj->_class->hasProperty(npobj, propertyName);
 }
 
 bool NP_EXPORT
 _hasmethod(NPP npp, NPObject* npobj, NPIdentifier methodName)
 {
   if (!npp || !npobj || !npobj->_class || !npobj->_class->hasMethod)
     return false;
 
   NPPExceptionAutoHolder nppExceptionHolder;
   NPPAutoPusher nppPusher(npp);
 
+  NPN_PLUGIN_LOG(PLUGIN_LOG_NOISY,
+                 ("NPN_HasMethod(npp %p, npobj %p, property %p) called\n",
+                  npp, npobj, methodName));
+
   return npobj->_class->hasProperty(npobj, methodName);
 }
 
 void NP_EXPORT
 _releasevariantvalue(NPVariant* variant)
 {
   switch (variant->type) {
   case NPVariantType_Void :
   case NPVariantType_Null :
@@ -1931,18 +1997,20 @@ NPPExceptionAutoHolder::~NPPExceptionAut
 ////////////////////////////////////////////////////////////////////////
 NPError NP_EXPORT
 _getvalue(NPP npp, NPNVariable variable, void *result)
 {
   NPN_PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("NPN_GetValue: npp=%p, var=%d\n",
                                      (void*)npp, (int)variable));
 
   nsresult res;
 
+  PluginDestructionGuard guard(npp);
+
   switch(variable) {
 #if defined(XP_UNIX) && !defined(XP_MACOSX)
   case NPNVxDisplay : {
 #ifdef MOZ_WIDGET_GTK2
     if (npp) {
       ns4xPluginInstance *inst = (ns4xPluginInstance *) npp->ndata;
       NPBool rtv = PR_FALSE;
       inst->GetValue((nsPluginInstanceVariable)NPPVpluginNeedsXEmbed, &rtv);
       if (rtv) {
@@ -2113,18 +2181,20 @@ _setvalue(NPP npp, NPPVariable variable,
     return NPERR_INVALID_INSTANCE_ERROR;
 
   ns4xPluginInstance *inst = (ns4xPluginInstance *) npp->ndata;
 
   NS_ASSERTION(inst != NULL, "null instance");
 
   if (inst == NULL)
     return NPERR_INVALID_INSTANCE_ERROR;
 
+  PluginDestructionGuard guard(inst);
+
   switch (variable) {
 
     // we should keep backward compatibility with 4x where the
     // actual pointer value is checked rather than its content
     // wnen passing booleans
     case NPPVpluginWindowBool: {
       NPBool bWindowless = (result == nsnull);
       return inst->SetWindowless(bWindowless);
     }
diff -u -9 -p -r1.37 ns4xPlugin.h
--- modules/plugin/base/src/ns4xPlugin.h	23 Feb 2005 23:17:57 -0000	1.37
+++ modules/plugin/base/src/ns4xPlugin.h	26 Aug 2008 03:59:02 -0000
@@ -261,23 +261,34 @@ public:
   static NPP Peek()
   {
     return sCurrentNPP;
   }
 
 protected:
   static NPP sCurrentNPP;
 };
 
-class NPPAutoPusher : public NPPStack
+// XXXjst: The NPPAutoPusher stack is a bit redundant now that
+// PluginDestructionGuard exists, and could thus be replaced by code
+// that uses the PluginDestructionGuard list of plugins on the
+// stack. But they're not identical, and to minimize code changes
+// we're keeping both for the moment, and making NPPAutoPusher inherit
+// the PluginDestructionGuard class to avoid having to keep two
+// separate objects on the stack since we always want a
+// PluginDestructionGuard where we use an NPPAutoPusher.
+
+class NPPAutoPusher : public NPPStack,
+                      protected PluginDestructionGuard
 {
 public:
   NPPAutoPusher(NPP npp)
-    : mOldNPP(sCurrentNPP)
+    : PluginDestructionGuard(npp),
+      mOldNPP(sCurrentNPP)
   {
     NS_ASSERTION(npp, "Uh, null npp passed to NPPAutoPusher!");
 
     sCurrentNPP = npp;
   }
 
   ~NPPAutoPusher()
   {
     sCurrentNPP = mOldNPP;
diff -u -9 -p -r1.125.4.4 ns4xPluginInstance.cpp
--- modules/plugin/base/src/ns4xPluginInstance.cpp	6 Jul 2007 18:21:30 -0000	1.125.4.4
+++ modules/plugin/base/src/ns4xPluginInstance.cpp	26 Aug 2008 03:59:03 -0000
@@ -167,18 +167,20 @@ nsresult ns4xPluginStreamListener::Clean
 {
   nsresult rv = NS_ERROR_FAILURE;
 
   if(mStreamCleanedUp)
     return NS_OK;
 
   if(!mInst || !mInst->IsStarted())
     return rv;
 
+  PluginDestructionGuard guard(mInst);
+
   const NPPluginFuncs *callbacks = nsnull;
   mInst->GetCallbacks(&callbacks);
   if(!callbacks)
     return rv;
 
   NPP npp;
   mInst->GetNPP(&npp);
 
   if (mStreamStarted && callbacks->destroystream != NULL)
@@ -211,18 +213,20 @@ nsresult ns4xPluginStreamListener::Clean
 }
 
 
 ///////////////////////////////////////////////////////////////////////////////
 void ns4xPluginStreamListener::CallURLNotify(NPReason reason)
 {
   if(!mCallNotify || !mInst || !mInst->IsStarted())
     return;
 
+  PluginDestructionGuard guard(mInst);
+
   mCallNotify = PR_FALSE; // only do this ONCE and prevent recursion
 
   const NPPluginFuncs *callbacks = nsnull;
   mInst->GetCallbacks(&callbacks);
   if(!callbacks)
     return;
   
   if (callbacks->urlnotify) {
 
@@ -248,18 +252,20 @@ void ns4xPluginStreamListener::CallURLNo
 
 
 ///////////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP
 ns4xPluginStreamListener::OnStartBinding(nsIPluginStreamInfo* pluginInfo)
 {
   if(!mInst)
     return NS_ERROR_FAILURE;
 
+  PluginDestructionGuard guard(mInst);
+
   NPP npp;
   const NPPluginFuncs *callbacks = nsnull;
 
   mInst->GetCallbacks(&callbacks);
   mInst->GetNPP(&npp);
 
   if(!callbacks || !mInst->IsStarted())
     return NS_ERROR_FAILURE;
 
@@ -395,18 +401,20 @@ ns4xPluginStreamListener::StopDataPump()
 // internal buffer.
 NS_IMETHODIMP
 ns4xPluginStreamListener::OnDataAvailable(nsIPluginStreamInfo* pluginInfo,
                                           nsIInputStream* input,
                                           PRUint32 length)
 {
   if (!mInst || !mInst->IsStarted())
     return NS_ERROR_FAILURE;
 
+  PluginDestructionGuard guard(mInst);
+
   // Just in case the caller switches plugin info on us.
   mStreamInfo = pluginInfo;
 
   const NPPluginFuncs *callbacks = nsnull;
   mInst->GetCallbacks(&callbacks);
   // check out if plugin implements NPP_Write call
   if(!callbacks || !callbacks->write || !length)
     return NS_ERROR_FAILURE; // it'll cancel necko transaction 
   
@@ -655,18 +663,20 @@ ns4xPluginStreamListener::OnDataAvailabl
 
 ///////////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP
 ns4xPluginStreamListener::OnFileAvailable(nsIPluginStreamInfo* pluginInfo, 
                                           const char* fileName)
 {
   if(!mInst || !mInst->IsStarted())
     return NS_ERROR_FAILURE;
 
+  PluginDestructionGuard guard(mInst);
+
   const NPPluginFuncs *callbacks = nsnull;
   mInst->GetCallbacks(&callbacks);
   if(!callbacks && !callbacks->asfile)
     return NS_ERROR_FAILURE;
   
   NPP npp;
   mInst->GetNPP(&npp);
 
   PRLibrary* lib = nsnull;
@@ -936,18 +946,24 @@ NS_IMETHODIMP ns4xPluginInstance::Stop(v
   if (mXlibXtBin) {
     mXlibXtBin->xtbin_destroy();
     mXlibXtBin = 0;
   }
 #endif
 
   if(!mStarted)
     return NS_OK;
 
+  // If there's code from this plugin instance on the stack, delay the
+  // destroy.
+  if (PluginDestructionGuard::DelayDestroy(this)) {
+    return NS_OK;
+  }
+
   if (fCallbacks->destroy == NULL)
     return NS_ERROR_FAILURE; // XXX right error?
 
   NPSavedData *sdata = 0;
 
   // clean up open streams
   for(nsInstanceStream *is = mStreams; is != nsnull;) {
     ns4xPluginStreamListener * listener = is->mPluginStreamListener;
 
@@ -1013,18 +1029,20 @@ ns4xPluginInstance::GetDOMWindow()
 
 ////////////////////////////////////////////////////////////////////////
 nsresult ns4xPluginInstance::InitializePlugin(nsIPluginInstancePeer* peer)
 {
   NS_ENSURE_ARG_POINTER(peer);
  
   nsCOMPtr<nsIPluginTagInfo2> taginfo = do_QueryInterface(peer);
   NS_ENSURE_TRUE(taginfo, NS_ERROR_NO_INTERFACE);
   
+  PluginDestructionGuard guard(this);
+
   PRUint16 count = 0;
   const char* const* names = nsnull;
   const char* const* values = nsnull;
   nsPluginTagType tagtype;
   nsresult rv = taginfo->GetTagType(&tagtype);
   if (NS_SUCCEEDED(rv)) {
     // Note: If we failed to get the tag type, we may be a full page plugin, so no arguments
     rv = taginfo->GetAttributes(count, names, values);
     NS_ENSURE_SUCCESS(rv, rv);
@@ -1394,18 +1412,20 @@ NS_IMETHODIMP ns4xPluginInstance::SetWin
     XFlush(ws->display);
   } // !window->ws_info
 
   // And now point the NPWindow structures window 
   // to the actual X window
   window->window = (nsPluginPort *)mXlibXtBin->xtbin_xtwindow();
 #endif // MOZ_WIDGET
 
   if (fCallbacks->setwindow) {
+    PluginDestructionGuard guard(this);
+
     // XXX Turns out that NPPluginWindow and NPWindow are structurally
     // identical (on purpose!), so there's no need to make a copy.
 
     PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("ns4xPluginInstance::SetWindow (about to call it) this=%p\n",this));
 
     NS_TRY_SAFE_CALL_RETURN(error, CallNPP_SetWindowProc(fCallbacks->setwindow,
                                   &fNPP,
                                   (NPWindow*) window), fLibrary, this);
 
@@ -1460,18 +1480,20 @@ nsresult ns4xPluginInstance::NewNotifySt
   NS_RELEASE(stream);
 
   return res;
 }
 
 NS_IMETHODIMP ns4xPluginInstance::Print(nsPluginPrint* platformPrint)
 {
   NS_ENSURE_TRUE(platformPrint, NS_ERROR_NULL_POINTER);
 
+  PluginDestructionGuard guard(this);
+
   NPPrint* thePrint = (NPPrint *)platformPrint;
 
   // to be compatible with the older SDK versions and to match what
   // 4.x and other browsers do, overwrite |window.type| field with one
   // more copy of |platformPrint|. See bug 113264
   if(fCallbacks) {
     PRUint16 sdkmajorversion = (fCallbacks->version & 0xff00)>>8;
     PRUint16 sdkminorversion = fCallbacks->version & 0x00ff;
     if((sdkmajorversion == 0) && (sdkminorversion < 11)) { 
@@ -1510,18 +1532,20 @@ NS_IMETHODIMP ns4xPluginInstance::Print(
 
 NS_IMETHODIMP ns4xPluginInstance::HandleEvent(nsPluginEvent* event, PRBool* handled)
 {
   if(!mStarted)
     return NS_OK;
 
   if (event == nsnull)
     return NS_ERROR_FAILURE;
 
+  PluginDestructionGuard guard(this);
+
   PRInt16 result = 0;
   
   if (fCallbacks->event) {
 #if defined(XP_MAC) || defined(XP_MACOSX)
     result = CallNPP_HandleEventProc(fCallbacks->event,
                                      &fNPP,
                                      (void*) event->event);
 #endif
 
@@ -1544,18 +1568,19 @@ NS_IMETHODIMP ns4xPluginInstance::Handle
     }
 
   return NS_OK;
 }
 
 nsresult ns4xPluginInstance::GetValueInternal(NPPVariable variable, void* value)
 {
   nsresult  res = NS_OK;
   if(fCallbacks->getvalue && mStarted) {
+    PluginDestructionGuard guard(this);
 
     NS_TRY_SAFE_CALL_RETURN(res, 
                             CallNPP_GetValueProc(fCallbacks->getvalue, 
                                                  &fNPP, 
                                                  variable, 
                                                  value), 
                                                  fLibrary, this);
     NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
     ("NPP GetValue called: this=%p, npp=%p, var=%d, value=%d, return=%d\n", 
diff -u -9 -p -r1.532.2.13 nsPluginHostImpl.cpp
--- modules/plugin/base/src/nsPluginHostImpl.cpp	17 Apr 2007 21:25:25 -0000	1.532.2.13
+++ modules/plugin/base/src/nsPluginHostImpl.cpp	26 Aug 2008 03:59:04 -0000
@@ -267,18 +267,20 @@ nsresult PostPluginUnloadEvent(PRLibrary
 
 static nsActivePluginList *gActivePluginList;
 
 #ifdef CALL_SAFETY_ON
 PRBool gSkipPluginSafeCalls = PR_FALSE;
 #endif
 
 nsIFile *nsPluginHostImpl::sPluginTempDir;
 
+nsPluginHostImpl *gPluginHost = nsnull;
+
 ////////////////////////////////////////////////////////////////////////
 // flat file reg funcs
 static
 PRBool ReadSectionHeader(nsPluginManifestLineReader& reader, const char *token)
 {
   do {
     if (*reader.LinePtr() == '[') {
       char* p = reader.LinePtr() + (reader.LineLength() - 1);
       if (*p != ']')
@@ -2627,18 +2629,22 @@ nsPluginHostImpl::GetPluginName(nsIPlugi
 ////////////////////////////////////////////////////////////////////////
 nsPluginHostImpl::~nsPluginHostImpl()
 {
   PLUGIN_LOG(PLUGIN_LOG_ALWAYS,("nsPluginHostImpl::dtor\n"));
 
 #ifdef NS_DEBUG
   printf("nsPluginHostImpl dtor\n");
 #endif
   Destroy();
+
+  if (gPluginHost == this) {
+    gPluginHost = nsnull;
+  }
 }
 
 ////////////////////////////////////////////////////////////////////////
 NS_IMPL_ISUPPORTS7(nsPluginHostImpl,
                    nsIPluginManager,
                    nsIPluginManager2,
                    nsIPluginHost,
                    nsIFileUtilities,
                    nsICookieStorage,
@@ -2646,26 +2652,29 @@ NS_IMPL_ISUPPORTS7(nsPluginHostImpl,
                    nsPIPluginHost)
 ////////////////////////////////////////////////////////////////////////
 NS_METHOD
 nsPluginHostImpl::Create(nsISupports* aOuter, REFNSIID aIID, void** aResult)
 {
   NS_PRECONDITION(aOuter == nsnull, "no aggregation");
   if (aOuter)
     return NS_ERROR_NO_AGGREGATION;
 
-  nsPluginHostImpl* host = new nsPluginHostImpl();
-  if (! host)
-    return NS_ERROR_OUT_OF_MEMORY;
+  if (!gPluginHost) {
+    gPluginHost = new nsPluginHostImpl();
+    if (!gPluginHost)
+      return NS_ERROR_OUT_OF_MEMORY;
+  }
 
-  nsresult rv;
-  NS_ADDREF(host);
-  rv = host->QueryInterface(aIID, aResult);
-  NS_RELEASE(host);
+  gPluginHost->AddRef();
+  nsresult rv = gPluginHost->QueryInterface(aIID, aResult);
+  // Can't use the macros here since they null out the pointer you
+  // release.
+  gPluginHost->Release();
   return rv;
 }
 
 
 ////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP nsPluginHostImpl::GetValue(nsPluginManagerVariable aVariable, void *aValue)
 {
   nsresult rv = NS_OK;
 
@@ -5940,18 +5949,22 @@ nsPluginHostImpl::AddHeadersToChannel(co
   }
   return rv;
 }
 
 
 ////////////////////////////////////////////////////////////////////////
 NS_IMETHODIMP
 nsPluginHostImpl::StopPluginInstance(nsIPluginInstance* aInstance)
 {
+  if (PluginDestructionGuard::DelayDestroy(aInstance)) {
+    return NS_OK;
+  }
+
   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
   ("nsPluginHostImpl::StopPluginInstance called instance=%p\n",aInstance));
 
   nsActivePlugin * plugin = mActivePluginList.find(aInstance);
 
   if(plugin != nsnull) {
     plugin->setStopped(PR_TRUE);  // be sure we set the "stop" bit
 
     // if the plugin does not want to be 'cached' just remove it
@@ -6871,9 +6884,166 @@ nsPluginStreamInfo::SetStreamComplete(co
 {
   mStreamComplete = complete;
 
   if (complete) {
     // We're done, release the request.
 
     SetRequest(nsnull);
   }
 }
+
+
+// Event that does an async destroy of a plugin.
+
+class nsPluginDestroyEvent : public PLEvent,
+                             public PRCList
+{
+public:
+  nsPluginDestroyEvent(nsIPluginInstance *aInstance)
+    : mInstance(aInstance)
+  {
+    MOZ_COUNT_CTOR(nsPluginDestroyEvent);
+    PL_InitEvent(this, aInstance, Handle, Destroy);
+
+    PR_INIT_CLIST(this);
+    PR_APPEND_LINK(this, &sEventListHead);
+  }
+
+  ~nsPluginDestroyEvent()
+  {
+    MOZ_COUNT_DTOR(nsPluginDestroyEvent);
+    PR_REMOVE_LINK(this);
+  }
+
+  PR_STATIC_CALLBACK(void*) Handle(PLEvent* aEvent);
+  PR_STATIC_CALLBACK(void) Destroy(PLEvent* aEvent);
+
+protected:
+  nsCOMPtr<nsIPluginInstance> mInstance;
+
+  static PRCList sEventListHead;
+};
+
+// static
+void *
+nsPluginDestroyEvent::Handle(PLEvent* aEvent)
+{
+  nsPluginDestroyEvent* evt =
+    NS_STATIC_CAST(nsPluginDestroyEvent*, aEvent);
+
+  nsCOMPtr<nsIPluginInstance> instance;
+
+  // Null out mInstance to make sure this code in another runnable
+  // will do the right thing even if someone was holding on to this
+  // runnable longer than we expect.
+  instance.swap(evt->mInstance);
+
+  if (PluginDestructionGuard::DelayDestroy(instance)) {
+    // It's still not safe to destroy the plugin, it's now up to the
+    // outermost guard on the stack to take care of the destruction.
+
+    return nsnull;
+  }
+
+  nsPluginDestroyEvent *r =
+    static_cast<nsPluginDestroyEvent*>(PR_NEXT_LINK(&sEventListHead));
+
+  while (r != &sEventListHead) {
+    if (r != evt && r->mInstance == instance) {
+      // There's another event scheduled to tear down
+      // instance. Let it do the job.
+ 
+      return nsnull;
+    }
+
+    r = static_cast<nsPluginDestroyEvent*>(PR_NEXT_LINK(r));
+  }
+
+  PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+             ("Doing delayed destroy of instance %p\n", instance.get()));
+
+  instance->Stop();
+
+  if (gPluginHost) {
+    gPluginHost->StopPluginInstance(instance);
+  }
+
+  PLUGIN_LOG(PLUGIN_LOG_NORMAL,
+             ("Done with delayed destroy of instance %p\n", instance.get()));
+
+  return nsnull;
+}
+
+// static
+void PR_CALLBACK
+nsPluginDestroyEvent::Destroy(PLEvent* aEvent)
+{
+  nsPluginDestroyEvent* evt =
+    NS_STATIC_CAST(nsPluginDestroyEvent*, aEvent);
+  delete evt;
+}
+
+PRCList nsPluginDestroyEvent::sEventListHead =
+  PR_INIT_STATIC_CLIST(&nsPluginDestroyEvent::sEventListHead);
+
+PRCList PluginDestructionGuard::sListHead =
+  PR_INIT_STATIC_CLIST(&PluginDestructionGuard::sListHead);
+
+PluginDestructionGuard::~PluginDestructionGuard()
+{
+  PR_REMOVE_LINK(this);
+
+  if (mDelayedDestroy) {
+    // We've attempted to destroy the plugin instance we're holding on
+    // to while we were guarding it. Do the actual destroy now, off of
+    // a runnable.
+
+    nsresult rv;
+    nsCOMPtr<nsIEventQueueService> eventQService =
+      do_GetService("@mozilla.org/event-queue-service;1", &rv);
+
+    nsCOMPtr<nsIEventQueue> eventQ;
+    if (eventQService) {
+      rv = eventQService->
+        GetSpecialEventQueue(nsIEventQueueService::UI_THREAD_EVENT_QUEUE,
+                             getter_AddRefs(eventQ));
+    }
+
+    if (eventQ) {
+      nsPluginDestroyEvent *evt =
+        new nsPluginDestroyEvent(mInstance);
+
+      if (evt) {
+        rv = eventQ->PostEvent(evt);
+
+        if (NS_FAILED(rv)) {
+          PL_DestroyEvent(evt);
+        }
+      }
+    }
+  }
+}
+
+// static
+PRBool
+PluginDestructionGuard::DelayDestroy(nsIPluginInstance *aInstance)
+{
+  NS_ASSERTION(aInstance, "Uh, I need an instance!");
+
+  // Find the first guard on the stack and make it do a delayed
+  // destroy upon destruction.
+
+  PluginDestructionGuard *g =
+    static_cast<PluginDestructionGuard*>(PR_LIST_HEAD(&sListHead));
+
+  while (g != &sListHead) {
+    if (g->mInstance == aInstance) {
+      g->mDelayedDestroy = PR_TRUE;
+
+      return PR_TRUE;
+    }
+
+    g = static_cast<PluginDestructionGuard*>(PR_NEXT_LINK(g));    
+  }
+
+  return PR_FALSE;
+}
diff -u -9 -p -r1.99.4.1 nsPluginHostImpl.h
--- modules/plugin/base/src/nsPluginHostImpl.h	28 Jan 2007 19:44:05 -0000	1.99.4.1
+++ modules/plugin/base/src/nsPluginHostImpl.h	26 Aug 2008 03:59:04 -0000
@@ -40,18 +40,21 @@
 
 #include "nsIPluginManager.h"
 #include "nsIPluginManager2.h"
 #include "nsIPluginHost.h"
 #include "nsIObserver.h"
 #include "nsPIPluginHost.h"
 #include "nsCRT.h"
 #include "nsCOMPtr.h"
 #include "prlink.h"
+#include "prclist.h"
+#include "npapi.h"
+#include "ns4xPluginInstance.h"
 
 #include "nsIPlugin.h"
 #include "nsIPluginTagInfo2.h"
 #include "nsIPluginInstancePeer2.h"
 
 #include "nsIFileUtilities.h"
 #include "nsICookieStorage.h"
 #include "nsPluginsDir.h"
 #include "nsVoidArray.h"  // array for holding "active" streams
@@ -511,10 +514,44 @@ private:
   nsCOMPtr<nsIFile>                    mPluginRegFile;
   nsCOMPtr<nsIPrefBranch>              mPrefService;
   nsRefPtr<nsPluginDirServiceProvider> mPrivateDirServiceProvider;
 
   nsWeakPtr mCurrentDocument; // weak reference, we use it to id document only
 
   static nsIFile *sPluginTempDir;
 };
 
+class PluginDestructionGuard : protected PRCList
+{
+public:
+  PluginDestructionGuard(nsIPluginInstance *aInstance)
+    : mInstance(aInstance)
+  {
+    Init();
+  }
+
+  PluginDestructionGuard(NPP npp)
+    : mInstance(npp ? static_cast<ns4xPluginInstance*>(npp->ndata) : nsnull)
+  {
+    Init();
+  }
+
+  ~PluginDestructionGuard();
+
+  static PRBool DelayDestroy(nsIPluginInstance *aInstance);
+
+protected:
+  void Init()
+  {
+    mDelayedDestroy = PR_FALSE;
+
+    PR_INIT_CLIST(this);
+    PR_INSERT_BEFORE(this, &sListHead);
+  }
+
+  nsCOMPtr<nsIPluginInstance> mInstance;
+  PRBool mDelayedDestroy;
+
+  static PRCList sListHead;
+};
+
 #endif
