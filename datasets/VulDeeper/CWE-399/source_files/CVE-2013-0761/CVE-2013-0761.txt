diff --git a/content/media/TrackUnionStream.h b/content/media/TrackUnionStream.h
--- a/content/media/TrackUnionStream.h
+++ b/content/media/TrackUnionStream.h
@@ -51,33 +51,34 @@ public:
       if (!stream->IsFinishedOnGraphThread()) {
         allFinished = false;
       }
       for (StreamBuffer::TrackIter tracks(stream->GetStreamBuffer());
            !tracks.IsEnded(); tracks.Next()) {
         bool found = false;
         for (uint32_t j = 0; j < mTrackMap.Length(); ++j) {
           TrackMapEntry* map = &mTrackMap[j];
-          if (map->mInputPort == mInputs[i] && map->mInputTrack == tracks.get()) {
+          if (map->mInputPort == mInputs[i] && map->mInputTrackID == tracks->GetID()) {
             bool trackFinished;
-            if (map->mOutputTrack->IsEnded()) {
+            StreamBuffer::Track* outputTrack = mBuffer.FindTrack(map->mOutputTrackID);
+            if (!outputTrack || outputTrack->IsEnded()) {
               trackFinished = true;
             } else {
-              CopyTrackData(j, aFrom, aTo, &trackFinished);
+              CopyTrackData(tracks.get(), j, aFrom, aTo, &trackFinished);
             }
             mappedTracksFinished[j] = trackFinished;
             mappedTracksWithMatchingInputTracks[j] = true;
             found = true;
             break;
           }
         }
         if (!found) {
           bool trackFinished = false;
           uint32_t mapIndex = AddTrack(mInputs[i], tracks.get(), aFrom);
-          CopyTrackData(mapIndex, aFrom, aTo, &trackFinished);
+          CopyTrackData(tracks.get(), mapIndex, aFrom, aTo, &trackFinished);
           mappedTracksFinished.AppendElement(trackFinished);
           mappedTracksWithMatchingInputTracks.AppendElement(true);
         }
       }
     }
     for (int32_t i = mTrackMap.Length() - 1; i >= 0; --i) {
       if (mappedTracksFinished[i]) {
         EndTrack(i);
@@ -96,18 +97,23 @@ public:
     }
     mBuffer.AdvanceKnownTracksTime(GraphTimeToStreamTime(aTo));
   }
 
 protected:
   // Only non-ended tracks are allowed to persist in this map.
   struct TrackMapEntry {
     MediaInputPort* mInputPort;
-    StreamBuffer::Track* mInputTrack;
-    StreamBuffer::Track* mOutputTrack;
+    // We keep track IDs instead of track pointers because
+    // tracks can be removed without us being notified (e.g.
+    // when a finished track is forgotten.) When we need a Track*,
+    // we call StreamBuffer::FindTrack, which will return null if
+    // the track has been deleted.
+    TrackID mInputTrackID;
+    TrackID mOutputTrackID;
     nsAutoPtr<MediaSegment> mSegment;
   };
 
   uint32_t AddTrack(MediaInputPort* aPort, StreamBuffer::Track* aTrack,
                     GraphTime aFrom)
   {
     // Use the ID of the source track if we can, otherwise allocate a new
     // unique ID
@@ -132,50 +138,50 @@ protected:
     StreamBuffer::Track* track =
       &mBuffer.AddTrack(id, rate, outputStart, segment.forget());
     LOG(PR_LOG_DEBUG, ("TrackUnionStream %p adding track %d for input stream %p track %d, start ticks %lld",
                        this, id, aPort->GetSource(), aTrack->GetID(),
                        (long long)outputStart));
 
     TrackMapEntry* map = mTrackMap.AppendElement();
     map->mInputPort = aPort;
-    map->mInputTrack = aTrack;
-    map->mOutputTrack = track;
+    map->mInputTrackID = aTrack->GetID();
+    map->mOutputTrackID = track->GetID();
     map->mSegment = aTrack->GetSegment()->CreateEmptyClone();
     return mTrackMap.Length() - 1;
   }
   void EndTrack(uint32_t aIndex)
   {
-    StreamBuffer::Track* outputTrack = mTrackMap[aIndex].mOutputTrack;
-    if (outputTrack->IsEnded())
+    StreamBuffer::Track* outputTrack = mBuffer.FindTrack(mTrackMap[aIndex].mOutputTrackID);
+    if (!outputTrack || outputTrack->IsEnded())
       return;
     for (uint32_t j = 0; j < mListeners.Length(); ++j) {
       MediaStreamListener* l = mListeners[j];
       TrackTicks offset = outputTrack->GetSegment()->GetDuration();
       nsAutoPtr<MediaSegment> segment;
       segment = outputTrack->GetSegment()->CreateEmptyClone();
       l->NotifyQueuedTrackChanges(Graph(), outputTrack->GetID(),
                                   outputTrack->GetRate(), offset,
                                   MediaStreamListener::TRACK_EVENT_ENDED,
                                   *segment);
     }
     outputTrack->SetEnded();
   }
-  void CopyTrackData(uint32_t aMapIndex, GraphTime aFrom, GraphTime aTo,
+  void CopyTrackData(StreamBuffer::Track* aInputTrack,
+                     uint32_t aMapIndex, GraphTime aFrom, GraphTime aTo,
                      bool* aOutputTrackFinished)
   {
     TrackMapEntry* map = &mTrackMap[aMapIndex];
-    StreamBuffer::Track* inputTrack = map->mInputTrack;
-    StreamBuffer::Track* outputTrack = map->mOutputTrack;
+    StreamBuffer::Track* outputTrack = mBuffer.FindTrack(map->mOutputTrackID);
+    NS_ASSERTION(outputTrack && !outputTrack->IsEnded(), "Can't copy to ended track");
+
     TrackRate rate = outputTrack->GetRate();
     MediaSegment* segment = map->mSegment;
     MediaStream* source = map->mInputPort->GetSource();
 
-    NS_ASSERTION(!outputTrack->IsEnded(), "Can't copy to ended track");
-
     GraphTime next;
     *aOutputTrackFinished = false;
     for (GraphTime t = aFrom; t < aTo; t = next) {
       MediaInputPort::InputInterval interval = map->mInputPort->GetNextInputInterval(t);
       interval.mEnd = NS_MIN(interval.mEnd, aTo);
       if (interval.mStart >= interval.mEnd)
         break;
       next = interval.mEnd;
@@ -189,20 +195,20 @@ protected:
       NS_ASSERTION(startTicks == TimeToTicksRoundUp(rate, outputStart),
                    "Samples missing");
       TrackTicks endTicks = TimeToTicksRoundUp(rate, outputEnd);
       TrackTicks ticks = endTicks - startTicks;
       // StreamTime inputStart = source->GraphTimeToStreamTime(interval.mStart);
       StreamTime inputEnd = source->GraphTimeToStreamTime(interval.mEnd);
       TrackTicks inputTrackEndPoint = TRACK_TICKS_MAX;
 
-      if (inputTrack->IsEnded()) {
-        TrackTicks inputEndTicks = inputTrack->TimeToTicksRoundDown(inputEnd);
-        if (inputTrack->GetEnd() <= inputEndTicks) {
-          inputTrackEndPoint = inputTrack->GetEnd();
+      if (aInputTrack->IsEnded()) {
+        TrackTicks inputEndTicks = aInputTrack->TimeToTicksRoundDown(inputEnd);
+        if (aInputTrack->GetEnd() <= inputEndTicks) {
+          inputTrackEndPoint = aInputTrack->GetEnd();
           *aOutputTrackFinished = true;
         }
       }
 
       if (interval.mInputIsBlocked) {
         // Maybe the input track ended?
         segment->AppendNullData(ticks);
         LOG(PR_LOG_DEBUG, ("TrackUnionStream %p appending %lld ticks of null data to track %d",
@@ -212,17 +218,17 @@ protected:
         // because its start time and our start time may differ by a fraction
         // of a tick. Assuming the input track hasn't ended, we have to ensure
         // that 'ticks' samples are gathered, even though a tick boundary may
         // occur between outputStart and outputEnd but not between inputStart
         // and inputEnd.
         // We'll take the latest samples we can.
         TrackTicks inputEndTicks = TimeToTicksRoundUp(rate, inputEnd);
         TrackTicks inputStartTicks = inputEndTicks - ticks;
-        segment->AppendSlice(*inputTrack->GetSegment(),
+        segment->AppendSlice(*aInputTrack->GetSegment(),
                              NS_MIN(inputTrackEndPoint, inputStartTicks),
                              NS_MIN(inputTrackEndPoint, inputEndTicks));
         LOG(PR_LOG_DEBUG, ("TrackUnionStream %p appending %lld ticks of input data to track %d",
             this, (long long)(NS_MIN(inputTrackEndPoint, inputEndTicks) - NS_MIN(inputTrackEndPoint, inputStartTicks)),
             outputTrack->GetID()));
       }
       for (uint32_t j = 0; j < mListeners.Length(); ++j) {
         MediaStreamListener* l = mListeners[j];
