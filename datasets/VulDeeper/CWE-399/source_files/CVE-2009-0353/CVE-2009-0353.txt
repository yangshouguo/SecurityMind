diff
--- 31-ff.orig/js/src/jsinterp.cpp	2008-11-12 22:10:09.000000000 +0100
+++ 31-ff/js/src/jsinterp.cpp	2008-11-12 22:11:24.000000000 +0100
@@ -80,27 +80,32 @@
 #endif
 
 #include "jsautooplen.h"
 
 /* jsinvoke_cpp___ indicates inclusion from jsinvoke.cpp. */
 #if !JS_LONE_INTERPRET ^ defined jsinvoke_cpp___
 
 uint32
-js_GenerateShape(JSContext *cx, JSBool gcLocked)
+js_GenerateShape(JSContext *cx, JSBool gcLocked, JSScopeProperty *sprop)
 {
     JSRuntime *rt;
     uint32 shape;
+    JSTempValueRooter tvr;
 
     rt = cx->runtime;
     shape = JS_ATOMIC_INCREMENT(&rt->shapeGen);
     JS_ASSERT(shape != 0);
     if (shape & SHAPE_OVERFLOW_BIT) {
         rt->gcPoke = JS_TRUE;
+        if (sprop)
+            JS_PUSH_TEMP_ROOT_SPROP(cx, sprop, &tvr);
         js_GC(cx, gcLocked ? GC_LOCK_HELD : GC_NORMAL);
+        if (sprop)
+            JS_POP_TEMP_ROOT(cx, &tvr);
         shape = JS_ATOMIC_INCREMENT(&rt->shapeGen);
         JS_ASSERT(shape != 0);
         JS_ASSERT_IF(shape & SHAPE_OVERFLOW_BIT,
                      JS_PROPERTY_CACHE(cx).disabled);
     }
     return shape;
 }
 
diff
--- 31-ff.orig/js/src/jsinterp.h	2008-11-11 18:59:48.000000000 +0100
+++ 31-ff/js/src/jsinterp.h	2008-11-12 22:15:04.000000000 +0100
@@ -181,18 +181,22 @@ typedef struct JSInlineFrame {
 
 #define PCVCAP_MAKE(t,s,p)      (((t) << PCVCAP_TAGBITS) |                    \
                                  ((s) << PCVCAP_PROTOBITS) |                  \
                                  (p))
 #define PCVCAP_SHAPE(t)         ((t) >> PCVCAP_TAGBITS)
 
 #define SHAPE_OVERFLOW_BIT      JS_BIT(32 - PCVCAP_TAGBITS)
 
+/*
+ * When sprop is not null and the shape generation triggers the GC due to a
+ * shape overflow, the functions roots sprop.
+ */
 extern uint32
-js_GenerateShape(JSContext *cx, JSBool gcLocked);
+js_GenerateShape(JSContext *cx, JSBool gcLocked, JSScopeProperty *sprop);
 
 struct JSPropCacheEntry {
     jsbytecode          *kpc;           /* pc if vcap tag is <= 1, else atom */
     jsuword             kshape;         /* key shape if pc, else obj for atom */
     jsuword             vcap;           /* value capability, see above */
     jsuword             vword;          /* value word, see PCVAL_* below */
 };
 
diff
--- 31-ff.orig/js/src/jsscope.cpp	2008-11-11 18:59:48.000000000 +0100
+++ 31-ff/js/src/jsscope.cpp	2008-11-12 22:10:23.000000000 +0100
@@ -804,16 +804,17 @@ GetPropertyTreeChild(JSContext *cx, JSSc
                      JSScopeProperty *child)
 {
     JSRuntime *rt;
     JSDHashTable *table;
     JSPropertyTreeEntry *entry;
     JSScopeProperty *sprop;
     PropTreeKidsChunk *chunk;
     uintN i, n;
+    uint32 shape;
 
     rt = cx->runtime;
     if (!parent) {
         JS_LOCK_GC(rt);
 
         table = &rt->propertyTreeHash;
         entry = (JSPropertyTreeEntry *)
                 JS_DHashTableOperate(table, child, JS_DHASH_ADD);
@@ -890,29 +891,35 @@ GetPropertyTreeChild(JSContext *cx, JSSc
             }
         }
 
     not_found:
         JS_LOCK_GC(rt);
     }
 
 locked_not_found:
+    /*
+     * Call js_GenerateShape before the allocation to prevent collecting the
+     * new property when the shape generation triggers the GC.
+     */
+    shape = js_GenerateShape(cx, JS_TRUE, NULL);
+
     sprop = NewScopeProperty(rt);
     if (!sprop)
         goto out_of_memory;
 
     sprop->id = child->id;
     sprop->getter = child->getter;
     sprop->setter = child->setter;
     sprop->slot = child->slot;
     sprop->attrs = child->attrs;
     sprop->flags = child->flags;
     sprop->shortid = child->shortid;
     sprop->parent = sprop->kids = NULL;
-    sprop->shape = js_GenerateShape(cx, JS_TRUE);
+    sprop->shape = shape;
 
     if (!parent) {
         entry->child = sprop;
     } else {
         if (!InsertPropertyTreeChild(rt, parent, sprop, NULL))
             goto out_of_memory;
     }
 
diff
--- 31-ff.orig/js/src/jsscope.h	2008-11-11 18:59:48.000000000 +0100
+++ 31-ff/js/src/jsscope.h	2008-11-12 22:10:23.000000000 +0100
@@ -216,25 +216,25 @@ JS_STATIC_ASSERT(offsetof(JSScope, title
 #endif
 
 #define JS_IS_SCOPE_LOCKED(cx, scope)   JS_IS_TITLE_LOCKED(cx, &(scope)->title)
 
 #define OBJ_SCOPE(obj)                  ((JSScope *)(obj)->map)
 #define OBJ_SHAPE(obj)                  (OBJ_SCOPE(obj)->shape)
 
 #define SCOPE_MAKE_UNIQUE_SHAPE(cx,scope)                                     \
-    ((scope)->shape = js_GenerateShape((cx), JS_FALSE))
+    ((scope)->shape = js_GenerateShape((cx), JS_FALSE, NULL))
 
 #define SCOPE_EXTEND_SHAPE(cx,scope,sprop)                                    \
     JS_BEGIN_MACRO                                                            \
         if (!(scope)->lastProp ||                                             \
             (scope)->shape == (scope)->lastProp->shape) {                     \
             (scope)->shape = (sprop)->shape;                                  \
         } else {                                                              \
-            (scope)->shape = js_GenerateShape((cx), JS_FALSE);                \
+            (scope)->shape = js_GenerateShape((cx), JS_FALSE, sprop);         \
         }                                                                     \
     JS_END_MACRO
 
 /* By definition, hashShift = JS_DHASH_BITS - log2(capacity). */
 #define SCOPE_CAPACITY(scope)           JS_BIT(JS_DHASH_BITS-(scope)->hashShift)
 
 /* Scope flags and some macros to hide them from other files than jsscope.c. */
 #define SCOPE_MIDDLE_DELETE             0x0001
diff
--- 31-ff.orig/js/src/jsgc.cpp	2008-11-12 22:10:09.000000000 +0100
+++ 31-ff/js/src/jsgc.cpp	2008-11-12 22:10:23.000000000 +0100
@@ -3672,17 +3672,17 @@ out:
      */
     if (rt->gcLevel > 1 || rt->gcPoke) {
         rt->gcLevel = 1;
         rt->gcPoke = JS_FALSE;
         JS_UNLOCK_GC(rt);
         goto restart;
     }
 
-    if (rt->shapeGen & SHAPE_OVERFLOW_BIT) {
+    if (rt->shapeGen >= SHAPE_OVERFLOW_BIT - 1) {
         /*
          * FIXME bug 440834: The shape id space has overflowed. Currently we
          * cope badly with this. Every call to js_GenerateShape does GC, and
          * we never re-enable the property cache.
          */
         js_DisablePropertyCache(cx);
 #ifdef JS_THREADSAFE
         iter = NULL;
