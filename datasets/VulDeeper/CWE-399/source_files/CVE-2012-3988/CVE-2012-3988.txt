diff --git a/docshell/base/Makefile.in b/docshell/base/Makefile.in
--- a/docshell/base/Makefile.in
+++ b/docshell/base/Makefile.in
@@ -116,9 +116,12 @@ FORCE_STATIC_LIB = 1
 include $(topsrcdir)/config/rules.mk
 
 LOCAL_INCLUDES += \
   -I$(srcdir)/../shistory/src \
   -I$(topsrcdir)/dom/base \
   -I$(topsrcdir)/layout/base \
   -I$(topsrcdir)/js/xpconnect/src \
   -I$(topsrcdir)/xpcom/ds \
+  -I$(topsrcdir)/layout/generic \
+  -I$(topsrcdir)/layout/xul/base/src \
+  -I$(topsrcdir)/content/base/src \
   $(NULL)
diff --git a/docshell/base/nsDocShell.cpp b/docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp
+++ b/docshell/base/nsDocShell.cpp
@@ -200,16 +200,17 @@
 
 #include "nsIGlobalHistory2.h"
 
 #ifdef DEBUG_DOCSHELL_FOCUS
 #include "nsEventStateManager.h"
 #endif
 
 #include "nsIFrame.h"
+#include "nsSubDocumentFrame.h"
 
 // for embedding
 #include "nsIWebBrowserChromeFocus.h"
 
 #if NS_PRINT_PREVIEW
 #include "nsIDocumentViewerPrint.h"
 #include "nsIWebBrowserPrint.h"
 #endif
@@ -7027,16 +7028,27 @@ nsDocShell::RestoreFromHistory()
                 rootViewSibling = oldRootView->GetNextSibling();
                 rootViewParent = oldRootView->GetParent();
 
                 mContentViewer->GetBounds(newBounds);
             }
         }
     }
 
+    nsCOMPtr<nsIContent> container;
+    nsCOMPtr<nsIDocument> sibling;
+    if (rootViewParent && rootViewParent->GetParent()) {
+        nsIFrame* frame = static_cast<nsIFrame*>(rootViewParent->GetParent()->GetClientData());
+        container = frame ? frame->GetContent() : nsnull;
+    }
+    if (rootViewSibling) {
+        nsIFrame *frame = static_cast<nsIFrame*>(rootViewSibling->GetClientData());
+        sibling = frame ? frame->PresContext()->PresShell()->GetDocument() : nsnull;
+    }
+
     // Transfer ownership to mContentViewer.  By ensuring that either the
     // docshell or the session history, but not both, have references to the
     // content viewer, we prevent the viewer from being torn down after
     // Destroy() is called.
 
     if (mContentViewer) {
         mContentViewer->Close(mSavingOldViewer ? mOSHE.get() : nsnull);
         viewer->SetPreviousViewer(mContentViewer);
@@ -7113,17 +7125,17 @@ nsDocShell::RestoreFromHistory()
     // on the history entry in Destroy() just before marking itself non-sticky,
     // to avoid teardown of the presentation.
     mContentViewer->SetSticky(sticky);
 
     NS_ENSURE_SUCCESS(rv, rv);
 
     // mLSHE is now our currently-loaded document.
     SetHistoryEntry(&mOSHE, mLSHE);
-    
+
     // XXX special wyciwyg handling in Embed()?
 
     // We aren't going to restore any items from the LayoutHistoryState,
     // but we don't want them to stay around in case the page is reloaded.
     SetLayoutHistoryState(nsnull);
 
     // This is the end of our Embed() replacement
 
@@ -7226,20 +7238,30 @@ nsDocShell::RestoreFromHistory()
 
     nsCOMPtr<nsIPresShell> shell;
     nsDocShell::GetPresShell(getter_AddRefs(shell));
 
     nsIViewManager *newVM = shell ? shell->GetViewManager() : nsnull;
     nsIView *newRootView = newVM ? newVM->GetRootView() : nsnull;
 
     // Insert the new root view at the correct location in the view tree.
-    if (rootViewParent) {
-        nsIViewManager *parentVM = rootViewParent->GetViewManager();
-
-        if (parentVM && newRootView) {
+    if (container) {
+        nsSubDocumentFrame* subDocFrame = do_QueryFrame(container->GetPrimaryFrame());
+        rootViewParent = subDocFrame ? subDocFrame->EnsureInnerView() : nsnull;
+    }
+    if (sibling &&
+        sibling->GetShell() &&
+        sibling->GetShell()->GetViewManager()) {
+        rootViewSibling = sibling->GetShell()->GetViewManager()->GetRootView();
+    } else {
+        rootViewSibling = nsnull;
+    }
+    if (rootViewParent && newRootView && newRootView->GetParent() != rootViewParent) {
+         nsIViewManager *parentVM = rootViewParent->GetViewManager();
+        if (parentVM) {
             // InsertChild(parent, child, sib, true) inserts the child after
             // sib in content order, which is before sib in view order. BUT
             // when sib is null it inserts at the end of the the document
             // order, i.e., first in view order.  But when oldRootSibling is
             // null, the old root as at the end of the view list --- last in
             // content order --- and we want to call InsertChild(parent, child,
             // nsnull, false) in that case.
             parentVM->InsertChild(rootViewParent, newRootView,
