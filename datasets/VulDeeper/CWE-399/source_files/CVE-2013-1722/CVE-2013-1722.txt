diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -1756,17 +1756,16 @@ nsPresContext::RebuildAllStyleData(nsCha
   if (!mShell) {
     // We must have been torn down. Nothing to do here.
     return;
   }
 
   mUsesRootEMUnits = false;
   mUsesViewportUnits = false;
   RebuildUserFontSet();
-  AnimationManager()->KeyframesListIsDirty();
 
   RestyleManager()->RebuildAllStyleData(aExtraHint);
 }
 
 void
 nsPresContext::PostRebuildAllStyleDataEvent(nsChangeHint aExtraHint)
 {
   if (!mShell) {
diff --git a/layout/base/nsPresShell.cpp b/layout/base/nsPresShell.cpp
--- a/layout/base/nsPresShell.cpp
+++ b/layout/base/nsPresShell.cpp
@@ -4212,17 +4212,16 @@ nsIPresShell::ReconstructStyleDataIntern
 
   if (mIsDestroying) {
     // We don't want to mess with restyles at this point
     return;
   }
 
   if (mPresContext) {
     mPresContext->RebuildUserFontSet();
-    mPresContext->AnimationManager()->KeyframesListIsDirty();
   }
 
   Element* root = mDocument->GetRootElement();
   if (!mDidInitialize) {
     // Nothing to do here, since we have no frames yet
     return;
   }
 
diff --git a/layout/style/nsAnimationManager.cpp b/layout/style/nsAnimationManager.cpp
--- a/layout/style/nsAnimationManager.cpp
+++ b/layout/style/nsAnimationManager.cpp
@@ -524,17 +524,16 @@ nsAnimationManager::RulesMatching(XULTre
 
 /* virtual */ size_t
 nsAnimationManager::SizeOfExcludingThis(MallocSizeOf aMallocSizeOf) const
 {
   return CommonAnimationManager::SizeOfExcludingThis(aMallocSizeOf);
 
   // Measurement of the following members may be added later if DMD finds it is
   // worthwhile:
-  // - mKeyframesRules
   // - mPendingEvents
 }
 
 /* virtual */ size_t
 nsAnimationManager::SizeOfIncludingThis(MallocSizeOf aMallocSizeOf) const
 {
   return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);
 }
@@ -761,17 +760,18 @@ nsAnimationManager::BuildAnimations(nsSt
     if (aDest.IsPaused()) {
       aDest.mPauseStart = now;
     } else {
       aDest.mPauseStart = TimeStamp();
     }
 
     aDest.mIterationDuration = TimeDuration::FromMilliseconds(aSrc.GetDuration());
 
-    nsCSSKeyframesRule *rule = KeyframesRuleFor(aDest.mName);
+    nsCSSKeyframesRule* rule =
+      mPresContext->StyleSet()->KeyframesRuleForName(mPresContext, aDest.mName);
     if (!rule) {
       // no segments
       continue;
     }
 
     // While current drafts of css3-animations say that later keyframes
     // with the same key entirely replace earlier ones (no cascading),
     // this is a bad idea and contradictory to the rest of CSS.  So
@@ -1085,36 +1085,16 @@ nsAnimationManager::DoDispatchEvents()
     nsEventDispatcher::Dispatch(info.mElement, mPresContext, &info.mEvent);
 
     if (!mPresContext) {
       break;
     }
   }
 }
 
-nsCSSKeyframesRule*
-nsAnimationManager::KeyframesRuleFor(const nsSubstring& aName)
-{
-  if (mKeyframesListIsDirty) {
-    mKeyframesListIsDirty = false;
-
-    nsTArray<nsCSSKeyframesRule*> rules;
-    mPresContext->StyleSet()->AppendKeyframesRules(mPresContext, rules);
-
-    // Per css3-animations, the last @keyframes rule specified wins.
-    mKeyframesRules.Clear();
-    for (uint32_t i = 0, i_end = rules.Length(); i != i_end; ++i) {
-      nsCSSKeyframesRule *rule = rules[i];
-      mKeyframesRules.Put(rule->GetName(), rule);
-    }
-  }
-
-  return mKeyframesRules.Get(aName);
-}
-
 void
 nsAnimationManager::StopAllAnimations()
 {
   for (PRCList *l = PR_LIST_HEAD(&mElementData); l != &mElementData;
        l = PR_NEXT_LINK(l)) {
     ElementAnimations *ea = static_cast<ElementAnimations*>(l);
     bool needsRestyle = false;
     for (uint32_t animIdx = 0, animEnd = ea->mAnimations.Length();
diff --git a/layout/style/nsAnimationManager.h b/layout/style/nsAnimationManager.h
--- a/layout/style/nsAnimationManager.h
+++ b/layout/style/nsAnimationManager.h
@@ -193,20 +193,18 @@ struct ElementAnimations MOZ_FINAL
 };
 
 class nsAnimationManager MOZ_FINAL
   : public mozilla::css::CommonAnimationManager
 {
 public:
   nsAnimationManager(nsPresContext *aPresContext)
     : mozilla::css::CommonAnimationManager(aPresContext)
-    , mKeyframesListIsDirty(true)
     , mObservingRefreshDriver(false)
   {
-    mKeyframesRules.Init(16); // FIXME: make infallible!
   }
 
   static ElementAnimations* GetAnimationsForCompositor(nsIContent* aContent,
                                                        nsCSSProperty aProperty)
   {
     if (!aContent->MayHaveAnimations())
       return nullptr;
     ElementAnimations* animations = static_cast<ElementAnimations*>(
@@ -260,20 +258,16 @@ public:
    * RulesMatching does.)
    *
    * aStyleContext may be a style context for aElement or for its
    * :before or :after pseudo-element.
    */
   nsIStyleRule* CheckAnimationRule(nsStyleContext* aStyleContext,
                                    mozilla::dom::Element* aElement);
 
-  void KeyframesListIsDirty() {
-    mKeyframesListIsDirty = true;
-  }
-
   /**
    * Dispatch any pending events.  We accumulate animationend and
    * animationiteration events only during refresh driver notifications
    * (and dispatch them at the end of such notifications), but we
    * accumulate animationstart events at other points when style
    * contexts are created.
    */
   void DispatchEvents() {
@@ -318,22 +312,17 @@ private:
   bool BuildSegment(InfallibleTArray<AnimationPropertySegment>& aSegments,
                     nsCSSProperty aProperty, const nsAnimation& aAnimation,
                     float aFromKey, nsStyleContext* aFromContext,
                     mozilla::css::Declaration* aFromDeclaration,
                     float aToKey, nsStyleContext* aToContext);
   nsIStyleRule* GetAnimationRule(mozilla::dom::Element* aElement,
                                  nsCSSPseudoElements::Type aPseudoType);
 
-  nsCSSKeyframesRule* KeyframesRuleFor(const nsSubstring& aName);
-
   // The guts of DispatchEvents
   void DoDispatchEvents();
 
-  bool mKeyframesListIsDirty;
-  nsDataHashtable<nsStringHashKey, nsCSSKeyframesRule*> mKeyframesRules;
-
   EventArray mPendingEvents;
 
   bool mObservingRefreshDriver;
 };
 
 #endif /* !defined(nsAnimationManager_h_) */
diff --git a/layout/style/nsCSSRuleProcessor.cpp b/layout/style/nsCSSRuleProcessor.cpp
--- a/layout/style/nsCSSRuleProcessor.cpp
+++ b/layout/style/nsCSSRuleProcessor.cpp
@@ -939,16 +939,17 @@ struct RuleCascadeData {
                       aQuirksMode ? &AtomSelector_CIOps.ops :
                                     &AtomSelector_CSOps,
                       nullptr, sizeof(AtomSelectorEntry), 16);
     memset(mPseudoElementRuleHashes, 0, sizeof(mPseudoElementRuleHashes));
 #ifdef MOZ_XUL
     PL_DHashTableInit(&mXULTreeRules, &RuleHash_TagTable_Ops, nullptr,
                       sizeof(RuleHashTagTableEntry), 16);
 #endif
+    mKeyframesRuleTable.Init(16); // FIXME: make infallible!
   }
 
   ~RuleCascadeData()
   {
     PL_DHashTableFinish(&mAttributeSelectors);
     PL_DHashTableFinish(&mAnonBoxRules);
     PL_DHashTableFinish(&mIdSelectors);
     PL_DHashTableFinish(&mClassSelectors);
@@ -977,16 +978,18 @@ struct RuleCascadeData {
   PLDHashTable             mXULTreeRules;
 #endif
 
   nsTArray<nsFontFaceRuleContainer> mFontFaceRules;
   nsTArray<nsCSSKeyframesRule*> mKeyframesRules;
   nsTArray<nsCSSFontFeatureValuesRule*> mFontFeatureValuesRules;
   nsTArray<nsCSSPageRule*> mPageRules;
 
+  nsDataHashtable<nsStringHashKey, nsCSSKeyframesRule*> mKeyframesRuleTable;
+
   // Looks up or creates the appropriate list in |mAttributeSelectors|.
   // Returns null only on allocation failure.
   nsTArray<nsCSSSelector*>* AttributeListFor(nsIAtom* aAttribute);
 
   nsMediaQueryResultCacheKey mCacheKey;
   RuleCascadeData*  mNext; // for a different medium
 
   const bool mQuirksMode;
@@ -2771,31 +2774,27 @@ nsCSSRuleProcessor::AppendFontFaceRules(
   if (cascade) {
     if (!aArray.AppendElements(cascade->mFontFaceRules))
       return false;
   }
   
   return true;
 }
 
-// Append all the currently-active keyframes rules to aArray.  Return
-// true for success and false for failure.
-bool
-nsCSSRuleProcessor::AppendKeyframesRules(
-                              nsPresContext *aPresContext,
-                              nsTArray<nsCSSKeyframesRule*>& aArray)
+nsCSSKeyframesRule*
+nsCSSRuleProcessor::KeyframesRuleForName(nsPresContext* aPresContext,
+                                         const nsString& aName)
 {
   RuleCascadeData* cascade = GetRuleCascade(aPresContext);
 
   if (cascade) {
-    if (!aArray.AppendElements(cascade->mKeyframesRules))
-      return false;
+    return cascade->mKeyframesRuleTable.Get(aName);
   }
-  
-  return true;
+
+  return nullptr;
 }
 
 // Append all the currently-active page rules to aArray.  Return
 // true for success and false for failure.
 bool
 nsCSSRuleProcessor::AppendPageRules(
                               nsPresContext* aPresContext,
                               nsTArray<nsCSSPageRule*>& aArray)
@@ -3293,16 +3292,18 @@ FillWeightArray(PLDHashTable *table, PLD
   data->mWeightArray[data->mIndex++] = entry->data;
 
   return PL_DHASH_NEXT;
 }
 
 RuleCascadeData*
 nsCSSRuleProcessor::GetRuleCascade(nsPresContext* aPresContext)
 {
+  // FIXME:  Make this infallible!
+
   // If anything changes about the presentation context, we will be
   // notified.  Otherwise, our cache is valid if mLastPresContext
   // matches aPresContext.  (The only rule processors used for multiple
   // pres contexts are for XBL.  These rule processors are probably less
   // likely to have @media rules, and thus the cache is pretty likely to
   // hit instantly even when we're switching between pres contexts.)
 
   if (!mRuleCascades || aPresContext != mLastPresContext) {
@@ -3369,16 +3370,23 @@ nsCSSRuleProcessor::RefreshRuleCascade(n
         for (PerWeightDataListItem *cur = weightArray[i].mRuleSelectorPairs;
              cur;
              cur = cur->mNext) {
           if (!AddRule(cur, newCascade))
             return; /* out of memory */
         }
       }
 
+      // Build mKeyframesRuleTable.
+      for (nsTArray<nsCSSKeyframesRule*>::size_type i = 0,
+             iEnd = newCascade->mKeyframesRules.Length(); i < iEnd; ++i) {
+        nsCSSKeyframesRule* rule = newCascade->mKeyframesRules[i];
+        newCascade->mKeyframesRuleTable.Put(rule->GetName(), rule);
+      }
+
       // Ensure that the current one is always mRuleCascades.
       newCascade->mNext = mRuleCascades;
       mRuleCascades = newCascade.forget();
     }
   }
   return;
 }
 
diff --git a/layout/style/nsCSSRuleProcessor.h b/layout/style/nsCSSRuleProcessor.h
--- a/layout/style/nsCSSRuleProcessor.h
+++ b/layout/style/nsCSSRuleProcessor.h
@@ -118,18 +118,18 @@ public:
   virtual size_t SizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf)
     const MOZ_MUST_OVERRIDE MOZ_OVERRIDE;
 
   // Append all the currently-active font face rules to aArray.  Return
   // true for success and false for failure.
   bool AppendFontFaceRules(nsPresContext* aPresContext,
                            nsTArray<nsFontFaceRuleContainer>& aArray);
 
-  bool AppendKeyframesRules(nsPresContext* aPresContext,
-                            nsTArray<nsCSSKeyframesRule*>& aArray);
+  nsCSSKeyframesRule* KeyframesRuleForName(nsPresContext* aPresContext,
+                                           const nsString& aName);
 
   bool AppendPageRules(nsPresContext* aPresContext,
                        nsTArray<nsCSSPageRule*>& aArray);
 
   bool AppendFontFeatureValuesRules(nsPresContext* aPresContext,
                               nsTArray<nsCSSFontFeatureValuesRule*>& aArray);
 
   /**
diff --git a/layout/style/nsStyleSet.cpp b/layout/style/nsStyleSet.cpp
--- a/layout/style/nsStyleSet.cpp
+++ b/layout/style/nsStyleSet.cpp
@@ -117,16 +117,17 @@ nsDisableTextZoomStyleRule::MapRuleInfoI
 nsDisableTextZoomStyleRule::List(FILE* out, int32_t aIndent) const
 {
   for (int32_t index = aIndent; --index >= 0; ) fputs("  ", out);
   fputs("[disable text zoom style rule] {}\n", out);
 }
 #endif
 
 static const nsStyleSet::sheetType gCSSSheetTypes[] = {
+  // From lowest to highest in cascading order.
   nsStyleSet::eAgentSheet,
   nsStyleSet::eUserSheet,
   nsStyleSet::eDocSheet,
   nsStyleSet::eScopedDocSheet,
   nsStyleSet::eOverrideSheet
 };
 
 nsStyleSet::nsStyleSet()
@@ -1551,31 +1552,35 @@ nsStyleSet::AppendFontFaceRules(nsPresCo
     nsCSSRuleProcessor *ruleProc = static_cast<nsCSSRuleProcessor*>
                                     (mRuleProcessors[gCSSSheetTypes[i]].get());
     if (ruleProc && !ruleProc->AppendFontFaceRules(aPresContext, aArray))
       return false;
   }
   return true;
 }
 
-bool
-nsStyleSet::AppendKeyframesRules(nsPresContext* aPresContext,
-                                 nsTArray<nsCSSKeyframesRule*>& aArray)
+nsCSSKeyframesRule*
+nsStyleSet::KeyframesRuleForName(nsPresContext* aPresContext,
+                                 const nsString& aName)
 {
-  NS_ENSURE_FALSE(mInShutdown, false);
+  NS_ENSURE_FALSE(mInShutdown, nullptr);
 
-  for (uint32_t i = 0; i < ArrayLength(gCSSSheetTypes); ++i) {
+  for (uint32_t i = ArrayLength(gCSSSheetTypes); i-- != 0; ) {
     if (gCSSSheetTypes[i] == eScopedDocSheet)
       continue;
     nsCSSRuleProcessor *ruleProc = static_cast<nsCSSRuleProcessor*>
                                     (mRuleProcessors[gCSSSheetTypes[i]].get());
-    if (ruleProc && !ruleProc->AppendKeyframesRules(aPresContext, aArray))
-      return false;
+    if (!ruleProc)
+      continue;
+    nsCSSKeyframesRule* result =
+      ruleProc->KeyframesRuleForName(aPresContext, aName);
+    if (result)
+      return result;
   }
-  return true;
+  return nullptr;
 }
 
 bool
 nsStyleSet::AppendFontFeatureValuesRules(nsPresContext* aPresContext,
                                  nsTArray<nsCSSFontFeatureValuesRule*>& aArray)
 {
   NS_ENSURE_FALSE(mInShutdown, false);
 
diff --git a/layout/style/nsStyleSet.h b/layout/style/nsStyleSet.h
--- a/layout/style/nsStyleSet.h
+++ b/layout/style/nsStyleSet.h
@@ -165,20 +165,19 @@ class nsStyleSet
                             nsICSSPseudoComparator* aComparator);
 #endif
 
   // Append all the currently-active font face rules to aArray.  Return
   // true for success and false for failure.
   bool AppendFontFaceRules(nsPresContext* aPresContext,
                              nsTArray<nsFontFaceRuleContainer>& aArray);
 
-  // Append all the currently-active keyframes rules to aArray.  Return
-  // true for success and false for failure.
-  bool AppendKeyframesRules(nsPresContext* aPresContext,
-                              nsTArray<nsCSSKeyframesRule*>& aArray);
+  // Return the winning (in the cascade) @keyframes rule for the given name.
+  nsCSSKeyframesRule* KeyframesRuleForName(nsPresContext* aPresContext,
+                                           const nsString& aName);
 
   // Fetch object for looking up font feature values
   already_AddRefed<gfxFontFeatureValueSet> GetFontFeatureValuesLookup();
 
   // Append all the currently-active font feature values rules to aArray.
   // Return true for success and false for failure.
   bool AppendFontFeatureValuesRules(nsPresContext* aPresContext,
                               nsTArray<nsCSSFontFeatureValuesRule*>& aArray);
