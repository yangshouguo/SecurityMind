diff --git a/gfx/thebes/gfxFont.cpp b/gfx/thebes/gfxFont.cpp
--- a/gfx/thebes/gfxFont.cpp
+++ b/gfx/thebes/gfxFont.cpp
@@ -25,16 +25,17 @@
 #include "gfxUserFontSet.h"
 #include "gfxPlatformFontList.h"
 #include "gfxScriptItemizer.h"
 #include "nsUnicodeProperties.h"
 #include "nsMathUtils.h"
 #include "nsBidiUtils.h"
 #include "nsUnicodeRange.h"
 #include "nsStyleConsts.h"
+#include "mozilla/FloatingPoint.h"
 #include "mozilla/Preferences.h"
 #include "mozilla/Services.h"
 #include "mozilla/Telemetry.h"
 #include "gfxSVGGlyphs.h"
 
 #include "cairo.h"
 #include "gfxFontTest.h"
 
@@ -1276,16 +1277,19 @@ void
 gfxFontCache::AddNew(gfxFont *aFont)
 {
     Key key(aFont->GetFontEntry(), aFont->GetStyle());
     HashEntry *entry = mFonts.PutEntry(key);
     if (!entry)
         return;
     gfxFont *oldFont = entry->mFont;
     entry->mFont = aFont;
+    // Assert that we can find the entry we just put in (this fails if the key
+    // has a NaN float value in it, e.g. 'sizeAdjust').
+    MOZ_ASSERT(entry == mFonts.GetEntry(key));
     // If someone's asked us to replace an existing font entry, then that's a
     // bit weird, but let it happen, and expire the old font if it's not used.
     if (oldFont && oldFont->GetExpirationState()->IsTracked()) {
         // if oldFont == aFont, recount should be > 0,
         // so we shouldn't be here.
         NS_ASSERTION(aFont != oldFont, "new font is tracked for expiry!");
         NotifyExpired(oldFont);
     }
@@ -1314,18 +1318,19 @@ gfxFontCache::NotifyExpired(gfxFont *aFo
     DestroyFont(aFont);
 }
 
 void
 gfxFontCache::DestroyFont(gfxFont *aFont)
 {
     Key key(aFont->GetFontEntry(), aFont->GetStyle());
     HashEntry *entry = mFonts.GetEntry(key);
-    if (entry && entry->mFont == aFont)
+    if (entry && entry->mFont == aFont) {
         mFonts.RemoveEntry(key);
+    }
     NS_ASSERTION(aFont->GetRefCount() == 0,
                  "Destroying with non-zero ref count!");
     delete aFont;
 }
 
 /*static*/
 PLDHashOperator
 gfxFontCache::AgeCachedWordsForFont(HashEntry* aHashEntry, void* aUserData)
@@ -4213,16 +4218,19 @@ gfxFontStyle::gfxFontStyle(uint8_t aStyl
                            const nsString& aLanguageOverride):
     language(aLanguage),
     size(aSize), sizeAdjust(aSizeAdjust),
     languageOverride(ParseFontLanguageOverride(aLanguageOverride)),
     weight(aWeight), stretch(aStretch),
     systemFont(aSystemFont), printerFont(aPrinterFont),
     style(aStyle)
 {
+    MOZ_ASSERT(!MOZ_DOUBLE_IS_NaN(size));
+    MOZ_ASSERT(!MOZ_DOUBLE_IS_NaN(sizeAdjust));
+
     if (weight > 900)
         weight = 900;
     if (weight < 100)
         weight = 100;
 
     if (size >= FONT_MAX_SIZE) {
         size = FONT_MAX_SIZE;
         sizeAdjust = 0.0;
diff --git a/gfx/thebes/gfxFont.h b/gfx/thebes/gfxFont.h
--- a/gfx/thebes/gfxFont.h
+++ b/gfx/thebes/gfxFont.h
@@ -123,24 +123,27 @@ struct THEBES_API gfxFontStyle {
         return ((style + (systemFont << 7) +
             (weight << 8)) + uint32_t(size*1000) + uint32_t(sizeAdjust*1000)) ^
             nsISupportsHashKey::HashKey(language);
     }
 
     int8_t ComputeWeight() const;
 
     bool Equals(const gfxFontStyle& other) const {
-        return (size == other.size) &&
+        return
+            (*reinterpret_cast<const uint64_t*>(&size) ==
+             *reinterpret_cast<const uint64_t*>(&other.size)) &&
             (style == other.style) &&
             (systemFont == other.systemFont) &&
             (printerFont == other.printerFont) &&
             (weight == other.weight) &&
             (stretch == other.stretch) &&
             (language == other.language) &&
-            (sizeAdjust == other.sizeAdjust) &&
+            (*reinterpret_cast<const uint32_t*>(&sizeAdjust) ==
+             *reinterpret_cast<const uint32_t*>(&other.sizeAdjust)) &&
             (featureSettings == other.featureSettings) &&
             (languageOverride == other.languageOverride);
     }
 
     static void ParseFontFeatureSettings(const nsString& aFeatureString,
                                          nsTArray<gfxFontFeature>& aFeatures);
 
     static uint32_t ParseFontLanguageOverride(const nsString& aLangTag);
