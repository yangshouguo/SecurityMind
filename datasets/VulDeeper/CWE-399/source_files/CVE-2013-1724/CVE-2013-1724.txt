diff --git a/content/base/public/DirectionalityUtils.h b/content/base/public/DirectionalityUtils.h
--- a/content/base/public/DirectionalityUtils.h
+++ b/content/base/public/DirectionalityUtils.h
@@ -90,18 +90,22 @@ void SetDirectionFromChangedTextNode(nsI
  * When a text node is appended to an element, find any ancestors with dir=auto
  * whose directionality will be determined by the text node
  */
 void SetDirectionFromNewTextNode(nsIContent* aTextNode);
 
 /**
  * When a text node is removed from a document, find any ancestors whose
  * directionality it determined and redetermine their directionality
+ *
+ * @param aTextNode the text node
+ * @param aNullParent whether the the parent is also being removed
+ *        (passed from UnbindFromTree)
  */
-void ResetDirectionSetByTextNode(nsTextNode* aTextNode);
+void ResetDirectionSetByTextNode(nsTextNode* aTextNode, bool aNullParent);
 
 /**
  * Set the directionality of an element according to the directionality of the
  * text in aValue
  */
 void SetDirectionalityFromValue(mozilla::dom::Element* aElement,
                                 const nsAString& aValue,
                                 bool aNotify);
diff --git a/content/base/src/DirectionalityUtils.cpp b/content/base/src/DirectionalityUtils.cpp
--- a/content/base/src/DirectionalityUtils.cpp
+++ b/content/base/src/DirectionalityUtils.cpp
@@ -506,17 +506,17 @@ private:
   static PLDHashOperator ResetNodeDirection(nsPtrHashKey<Element>* aEntry, void* aData)
   {
     MOZ_ASSERT(aEntry->GetKey()->IsElement(), "Must be an Element");
     // run the downward propagation algorithm
     // and remove the text node from the map
     nsINode* oldTextNode = static_cast<Element*>(aData);
     Element* rootNode = aEntry->GetKey();
     nsINode* newTextNode = nullptr;
-    if (rootNode->HasDirAuto()) {
+    if (oldTextNode && rootNode->HasDirAuto()) {
       newTextNode = WalkDescendantsSetDirectionFromText(rootNode, true,
                                                         oldTextNode);
     }
     if (newTextNode) {
       nsTextNodeDirectionalityMap::AddEntryToMap(newTextNode, rootNode);
     } else {
       rootNode->ClearHasDirAutoSet();
       rootNode->UnsetProperty(nsGkAtoms::dirAutoSetBy);
@@ -533,16 +533,21 @@ private:
   }
 
 public:
   void UpdateAutoDirection(Directionality aDir)
   {
     mElements.EnumerateEntries(SetNodeDirection, &aDir);
   }
 
+  void ClearAutoDirection()
+  {
+    mElements.EnumerateEntries(ResetNodeDirection, nullptr);
+  }
+
   void ResetAutoDirection(nsINode* aTextNode)
   {
     mElements.EnumerateEntries(ResetNodeDirection, aTextNode);
   }
 
   void EnsureMapIsClear(nsINode* aTextNode)
   {
 #ifdef DEBUG
@@ -571,16 +576,23 @@ public:
 
   static void UpdateTextNodeDirection(nsINode* aTextNode, Directionality aDir)
   {
     MOZ_ASSERT(aTextNode->HasTextNodeDirectionalityMap(),
                "Map missing in UpdateTextNodeDirection");
     GetDirectionalityMap(aTextNode)->UpdateAutoDirection(aDir);
   }
 
+  static void ClearTextNodeDirection(nsINode* aTextNode)
+  {
+    MOZ_ASSERT(aTextNode->HasTextNodeDirectionalityMap(),
+               "Map missing in ResetTextNodeDirection");
+    GetDirectionalityMap(aTextNode)->ClearAutoDirection();
+  }
+
   static void ResetTextNodeDirection(nsINode* aTextNode)
   {
     MOZ_ASSERT(aTextNode->HasTextNodeDirectionalityMap(),
                "Map missing in ResetTextNodeDirection");
     GetDirectionalityMap(aTextNode)->ResetAutoDirection(aTextNode);
   }
 
   static void EnsureMapIsClearFor(nsINode* aTextNode)
@@ -876,26 +888,30 @@ SetDirectionFromNewTextNode(nsIContent* 
 
   Directionality dir = GetDirectionFromText(aTextNode->GetText());
   if (dir != eDir_NotSet) {
     SetAncestorDirectionIfAuto(aTextNode, dir);
   }
 }
 
 void
-ResetDirectionSetByTextNode(nsTextNode* aTextNode)
+ResetDirectionSetByTextNode(nsTextNode* aTextNode, bool aNullParent)
 {
   if (!NodeAffectsDirAutoAncestor(aTextNode)) {
     nsTextNodeDirectionalityMap::EnsureMapIsClearFor(aTextNode);
     return;
   }
 
   Directionality dir = GetDirectionFromText(aTextNode->GetText());
   if (dir != eDir_NotSet && aTextNode->HasTextNodeDirectionalityMap()) {
-    nsTextNodeDirectionalityMap::ResetTextNodeDirection(aTextNode);
+    if (aNullParent) {
+      nsTextNodeDirectionalityMap::ClearTextNodeDirection(aTextNode);
+    } else {
+      nsTextNodeDirectionalityMap::ResetTextNodeDirection(aTextNode);
+    }
   }
 }
 
 void
 SetDirectionalityFromValue(Element* aElement, const nsAString& value,
                            bool aNotify)
 {
   Directionality dir = GetDirectionFromText(PromiseFlatString(value).get(),
diff --git a/content/base/src/nsTextNode.cpp b/content/base/src/nsTextNode.cpp
--- a/content/base/src/nsTextNode.cpp
+++ b/content/base/src/nsTextNode.cpp
@@ -142,17 +142,17 @@ nsTextNode::BindToTree(nsIDocument* aDoc
 
   SetDirectionFromNewTextNode(this);
 
   return NS_OK;
 }
 
 void nsTextNode::UnbindFromTree(bool aDeep, bool aNullParent)
 {
-  ResetDirectionSetByTextNode(this);
+  ResetDirectionSetByTextNode(this, aNullParent);
 
   nsGenericDOMDataNode::UnbindFromTree(aDeep, aNullParent);
 }
 
 #ifdef DEBUG
 void
 nsTextNode::List(FILE* out, int32_t aIndent) const
 {
