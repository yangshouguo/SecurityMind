diff --git a/content/svg/content/src/nsSVGNumberList.cpp b/content/svg/content/src/nsSVGNumberList.cpp
--- a/content/svg/content/src/nsSVGNumberList.cpp
+++ b/content/svg/content/src/nsSVGNumberList.cpp
@@ -254,26 +254,37 @@ nsSVGNumberList::InsertItemBefore(nsIDOM
 }
 
 /* nsIDOMSVGNumber replaceItem (in nsIDOMSVGNumber newItem, in unsigned long index); */
 NS_IMETHODIMP
 nsSVGNumberList::ReplaceItem(nsIDOMSVGNumber *newItem,
                              PRUint32 index,
                              nsIDOMSVGNumber **_retval)
 {
+  *_retval = nsnull;
+
   if (!newItem) {
-    *_retval = nsnull;
     return NS_ERROR_DOM_SVG_WRONG_TYPE_ERR;
   }
 
-  nsresult rv = RemoveItem(index, _retval);
-  if (NS_FAILED(rv))
-    return rv;
+  if (index >= mNumbers.Length()) {
+    return NS_ERROR_DOM_INDEX_SIZE_ERR;
+  }
 
-  return InsertElementAt(newItem, index);
+  WillModify();
+  NS_REMOVE_SVGVALUE_OBSERVER(mNumbers[index]);
+  NS_RELEASE(mNumbers[index]);
+  mNumbers[index] = newItem;
+  NS_ADDREF(newItem);
+  NS_ADD_SVGVALUE_OBSERVER(newItem);
+  DidModify();
+
+  NS_ADDREF(*_retval = newItem);
+
+  return NS_OK;
 }
 
 /* nsIDOMSVGNumberList removeItem (in unsigned long index); */
 NS_IMETHODIMP nsSVGNumberList::RemoveItem(PRUint32 index, nsIDOMSVGNumber **_retval)
 {
   if (index >= mNumbers.Length()) {
     *_retval = nsnull;
     return NS_ERROR_DOM_INDEX_SIZE_ERR;
diff --git a/content/svg/content/src/nsSVGPathSegList.cpp b/content/svg/content/src/nsSVGPathSegList.cpp
--- a/content/svg/content/src/nsSVGPathSegList.cpp
+++ b/content/svg/content/src/nsSVGPathSegList.cpp
@@ -237,29 +237,35 @@ NS_IMETHODIMP nsSVGPathSegList::InsertIt
 
 /* nsIDOMSVGPathSeg replaceItem (in nsIDOMSVGPathSeg newItem, in unsigned long index); */
 NS_IMETHODIMP nsSVGPathSegList::ReplaceItem(nsIDOMSVGPathSeg *newItem,
                                             PRUint32 index,
                                             nsIDOMSVGPathSeg **_retval)
 {
   NS_ENSURE_NATIVE_PATH_SEG(newItem, _retval);
 
+  if (index >= static_cast<PRUint32>(mSegments.Count())) {
+    return NS_ERROR_DOM_INDEX_SIZE_ERR;
+  }
+
   // immediately remove the new item from its current list
   nsSVGPathSeg* newItemSeg = static_cast<nsSVGPathSeg*>(newItem);
   RemoveFromCurrentList(newItemSeg);
 
+  // check length *again*, since mutation listener may have changed it!
   if (index >= static_cast<PRUint32>(mSegments.Count())) {
     return NS_ERROR_DOM_INDEX_SIZE_ERR;
   }
 
-  // NOTE: the new item can never be the item we will be replacing now that we removed it from its current list beforehand
-  InsertElementAt(newItemSeg, index);
-  RemoveFromCurrentList(static_cast<nsSVGPathSeg*>(mSegments.ObjectAt(index+1)));
+  WillModify();
+  mSegments.ReplaceObjectAt(newItemSeg, index);
+  newItemSeg->SetCurrentList(this);
+  DidModify();
+
   NS_ADDREF(*_retval = newItem);
-
   return NS_OK;
 }
 
 /* nsIDOMSVGPathSeg removeItem (in unsigned long index); */
 NS_IMETHODIMP nsSVGPathSegList::RemoveItem(PRUint32 index, nsIDOMSVGPathSeg **_retval)
 {
   if (index >= static_cast<PRUint32>(mSegments.Count())) {
     *_retval = nsnull;
