diff
--- tm.orig/js/src/xpconnect/src/xpcwrappednativejsops.cpp	2009-04-19 02:05:40.000000000 +0200
+++ tm/js/src/xpconnect/src/xpcwrappednativejsops.cpp	2009-04-19 04:01:09.000000000 +0200
@@ -464,31 +464,36 @@ DefinePropertyIfFound(XPCCallContext& cc
                                      propFlags);
     }
 
     // else...
 
     NS_ASSERTION(member->IsAttribute(), "way broken!");
 
     propFlags |= JSPROP_GETTER | JSPROP_SHARED;
+    JSObject* funobj = JSVAL_TO_OBJECT(funval);
+    JSPropertyOp getter = JS_DATA_TO_FUNC_PTR(JSPropertyOp, funobj);
+    JSPropertyOp setter;
     if(member->IsWritableAttribute())
     {
         propFlags |= JSPROP_SETTER;
         propFlags &= ~JSPROP_READONLY;
+        setter = getter;
+    }
+    else
+    {
+        setter = js_GetterOnlyPropertyStub;
     }
 
     AutoResolveName arn(ccx, idval);
     if(resolved)
         *resolved = JS_TRUE;
 
-    JSObject* funobj = JSVAL_TO_OBJECT(funval);
     return JS_ValueToId(ccx, idval, &id) &&
-           JS_DefinePropertyById(ccx, obj, id, JSVAL_VOID,
-                                 JS_DATA_TO_FUNC_PTR(JSPropertyOp, funobj),
-                                 JS_DATA_TO_FUNC_PTR(JSPropertyOp, funobj),
+           JS_DefinePropertyById(ccx, obj, id, JSVAL_VOID, getter, setter,
                                  propFlags);
 }
 
 /***************************************************************************/
 /***************************************************************************/
 
 static JSBool
 XPC_WN_OnlyIWrite_PropertyStub(JSContext *cx, JSObject *obj, jsval idval, jsval *vp)
diff
--- tm.orig/js/src/jsobj.cpp	2009-04-19 03:19:17.000000000 +0200
+++ tm/js/src/jsobj.cpp	2009-04-19 03:29:03.000000000 +0200
@@ -5985,16 +5985,31 @@ js_IsCallable(JSObject *obj, JSContext *
     JS_LOCK_OBJ(cx, obj);
     JSBool callable = (obj->map->ops == &js_ObjectOps)
                       ? HAS_FUNCTION_CLASS(obj) || STOBJ_GET_CLASS(obj)->call
                       : obj->map->ops->call != NULL;
     JS_UNLOCK_OBJ(cx, obj);
     return callable;
 }
 
+void
+js_ReportGetterOnlyAssignment(JSContext *cx)
+{
+    JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
+                         JSMSG_GETTER_ONLY, NULL);
+}
+
+
+JS_FRIEND_API(JSBool)
+js_GetterOnlyPropertyStub(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
+{
+    js_ReportGetterOnlyAssignment(cx);
+    return JS_FALSE;
+}
+
 #ifdef DEBUG
 
 /*
  * Routines to print out values during debugging.  These are FRIEND_API to help
  * the debugger find them and to support temporarily hacking js_Dump* calls
  * into other code.
  */
 
diff
--- tm.orig/js/src/jsobj.h	2009-04-19 03:15:44.000000000 +0200
+++ tm/js/src/jsobj.h	2009-04-19 03:24:08.000000000 +0200
@@ -834,16 +834,22 @@ js_GetWrappedObject(JSContext *cx, JSObj
 extern const char *
 js_ComputeFilename(JSContext *cx, JSStackFrame *caller,
                    JSPrincipals *principals, uintN *linenop);
 
 /* Infallible, therefore cx is last parameter instead of first. */
 extern JSBool
 js_IsCallable(JSObject *obj, JSContext *cx);
 
+void
+js_ReportGetterOnlyAssignment(JSContext *cx);
+
+extern JS_FRIEND_API(JSBool)
+js_GetterOnlyPropertyStub(JSContext *cx, JSObject *obj, jsval id, jsval *vp);
+
 #ifdef DEBUG
 JS_FRIEND_API(void) js_DumpChars(const jschar *s, size_t n);
 JS_FRIEND_API(void) js_DumpString(JSString *str);
 JS_FRIEND_API(void) js_DumpAtom(JSAtom *atom);
 JS_FRIEND_API(void) js_DumpValue(jsval val);
 JS_FRIEND_API(void) js_DumpId(jsid id);
 JS_FRIEND_API(void) js_DumpObject(JSObject *obj);
 #endif
diff
--- tm.orig/js/src/jsscope.h	2009-04-19 03:22:38.000000000 +0200
+++ tm/js/src/jsscope.h	2009-04-19 03:22:56.000000000 +0200
@@ -370,18 +370,17 @@ js_SetSprop(JSContext* cx, JSScopeProper
 
     if (sprop->attrs & JSPROP_SETTER) {
         jsval fval = js_CastAsObjectJSVal(sprop->setter);
         return js_InternalGetOrSet(cx, obj, (sprop)->id, fval, JSACC_WRITE,
                                    1, vp, vp);
     }
 
     if (sprop->attrs & JSPROP_GETTER) {
-        JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
-                             JSMSG_GETTER_ONLY, NULL);
+        js_ReportGetterOnlyAssignment(cx);
         return JS_FALSE;
     }
 
     return sprop->setter(cx, obj, SPROP_USERID(sprop), vp);
 }
 
 /* Macro for common expression to test for shared permanent attributes. */
 #define SPROP_IS_SHARED_PERMANENT(sprop)                                      \
diff
--- tm.orig/js/src/xpconnect/src/XPCIDispatchExtension.cpp	2009-04-19 03:25:43.000000000 +0200
+++ tm/js/src/xpconnect/src/XPCIDispatchExtension.cpp	2009-04-19 04:00:58.000000000 +0200
@@ -290,28 +290,33 @@ JSBool XPCIDispatchExtension::DefineProp
             *resolved = JS_TRUE;
         return JS_ValueToId(ccx, idval, &id) &&
                JS_DefinePropertyById(ccx, obj, id, OBJECT_TO_JSVAL(funobj),
                                      nsnull, nsnull, propFlags);
     }
     // Define the property on the object
     NS_ASSERTION(member->IsProperty(), "way broken!");
     propFlags |= JSPROP_GETTER | JSPROP_SHARED;
+    JSPropertyOp getter = JS_DATA_TO_FUNC_PTR(JSPropertyOp, funobj);
+    JSPropertyOp setter;
     if(member->IsSetter())
     {
         propFlags |= JSPROP_SETTER;
         propFlags &= ~JSPROP_READONLY;
+        setter = getter;
+    }
+    else
+    {
+        setter = js_GetterOnlyPropertyStub;
     }
     AutoResolveName arn(ccx, idval);
     if(resolved)
         *resolved = JS_TRUE;
     return JS_ValueToId(ccx, idval, &id) &&
-           JS_DefinePropertyById(ccx, obj, id, JSVAL_VOID,
-                                 JS_DATA_TO_FUNC_PTR(JSPropertyOp, funobj),
-                                 JS_DATA_TO_FUNC_PTR(JSPropertyOp, funobj),
+           JS_DefinePropertyById(ccx, obj, id, JSVAL_VOID, getter, setter,
                                  propFlags);
 
 }
 
 JSBool XPCIDispatchExtension::Enumerate(XPCCallContext& ccx, JSObject* obj,
                                         XPCWrappedNative * wrapper)
 {
     XPCNativeInterface* iface = XPCNativeInterface::GetNewOrUsed(
