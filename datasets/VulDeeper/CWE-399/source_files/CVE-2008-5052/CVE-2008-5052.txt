diff
--- mozilla/js/src/jsinterp.c
+++ mozilla/js/src/jsinterp.c
@@ -5147,17 +5147,17 @@
                 goto out;
             STORE_OPND(-1, rval);
             break;
 
           case JSOP_TOATTRVAL:
             rval = FETCH_OPND(-1);
             JS_ASSERT(JSVAL_IS_STRING(rval));
             SAVE_SP(fp);
-            str = js_EscapeAttributeValue(cx, JSVAL_TO_STRING(rval));
+            str = js_EscapeAttributeValue(cx, JSVAL_TO_STRING(rval), JS_FALSE);
             if (!str) {
                 ok = JS_FALSE;
                 goto out;
             }
             STORE_OPND(-1, STRING_TO_JSVAL(str));
             break;
 
           case JSOP_ADDATTRNAME:
diff
--- mozilla.orig/js/src/jsxml.c
+++ mozilla/js/src/jsxml.c
@@ -2343,25 +2343,24 @@
 
 /*
  * ECMA-357 10.2.1 17(d-g) pulled out into a common subroutine that appends
  * equals, a double quote, an attribute value, and a closing double quote.
  */
 static void
 AppendAttributeValue(JSContext *cx, JSStringBuffer *sb, JSString *valstr)
 {
-    js_AppendCString(sb, "=\"");
-    valstr = js_EscapeAttributeValue(cx, valstr);
+    js_AppendChar(sb, '=');
+    valstr = js_EscapeAttributeValue(cx, valstr, JS_TRUE);
     if (!valstr) {
         free(sb->base);
         sb->base = STRING_BUFFER_ERROR_BASE;
         return;
     }
     js_AppendJSString(sb, valstr);
-    js_AppendChar(sb, '"');
 }
 
 /*
  * ECMA-357 10.2.1.1 EscapeElementValue helper method.
  *
  * This function takes ownership of sb->base, if sb is non-null, in all cases
  * of success or failure.
  */
@@ -2414,23 +2413,25 @@
     return str;
 }
 
 /*
  * ECMA-357 10.2.1.2 EscapeAttributeValue helper method.
  * This function takes ownership of sb->base, if sb is non-null, in all cases.
  */
 static JSString *
-EscapeAttributeValue(JSContext *cx, JSStringBuffer *sb, JSString *str)
+EscapeAttributeValue(JSContext *cx, JSStringBuffer *sb, JSString *str,
+                     JSBool quote)
 {
     size_t length, newlength;
     const jschar *cp, *start, *end;
     jschar c;
 
-    length = newlength = JSSTRING_LENGTH(str);
+    length = JSSTRING_LENGTH(str);
+    newlength = length + (quote ? 2 : 0);
     for (cp = start = JSSTRING_CHARS(str), end = cp + length; cp < end; cp++) {
         c = *cp;
         if (c == '"')
             newlength += 5;
         else if (c == '<')
             newlength += 3;
         else if (c == '&' || c == '\n' || c == '\r' || c == '\t')
             newlength += 4;
@@ -2445,16 +2446,18 @@
         if (!sb) {
             sb = &localSB;
             js_InitStringBuffer(sb);
         }
         if (!sb->grow(sb, newlength)) {
             JS_ReportOutOfMemory(cx);
             return NULL;
         }
+        if (quote)
+            js_AppendChar(sb, '"');
         for (cp = start; cp < end; cp++) {
             c = *cp;
             if (c == '"')
                 js_AppendCString(sb, js_quot_entity_str);
             else if (c == '<')
                 js_AppendCString(sb, js_lt_entity_str);
             else if (c == '&')
                 js_AppendCString(sb, js_amp_entity_str);
@@ -2462,16 +2465,18 @@
                 js_AppendCString(sb, "&#xA;");
             else if (c == '\r')
                 js_AppendCString(sb, "&#xD;");
             else if (c == '\t')
                 js_AppendCString(sb, "&#x9;");
             else
                 js_AppendChar(sb, c);
         }
+        if (quote)
+            js_AppendChar(sb, '"');
         JS_ASSERT(STRING_BUFFER_OK(sb));
         str = js_NewString(cx, sb->base, STRING_BUFFER_OFFSET(sb), 0);
         if (!str)
             js_FinishStringBuffer(sb);
     }
     return str;
 }
 
@@ -2644,53 +2649,55 @@
     const JSXMLNamespace *nsb = (const JSXMLNamespace *) b;
 
     if (nsb->prefix)
         return nsa->prefix && !js_CompareStrings(nsa->prefix, nsb->prefix);
     return !js_CompareStrings(nsa->uri, nsb->uri);
 }
 
 /* ECMA-357 10.2.1 and 10.2.2 */
+#define TO_SOURCE_FLAG 0x80000000
+
 static JSString *
 XMLToXMLString(JSContext *cx, JSXML *xml, const JSXMLArray *ancestorNSes,
                uintN indentLevel)
 {
     JSBool pretty, indentKids;
     JSStringBuffer sb;
     JSString *str, *prefix, *kidstr;
     JSXMLArrayCursor cursor;
-    uint32 i, n;
+    uint32 i, n, nextIndentLevel;
     JSXMLArray empty, decls, ancdecls;
     JSXMLNamespace *ns, *ns2;
-    uintN nextIndentLevel;
     JSXML *attr, *kid;
 
     if (!GetBooleanXMLSetting(cx, js_prettyPrinting_str, &pretty))
         return NULL;
 
     js_InitStringBuffer(&sb);
     if (pretty)
-        js_RepeatChar(&sb, ' ', indentLevel);
+        js_RepeatChar(&sb, ' ', indentLevel & ~TO_SOURCE_FLAG);
     str = NULL;
 
     switch (xml->xml_class) {
       case JSXML_CLASS_TEXT:
         /* Step 4. */
         if (pretty) {
             str = ChompXMLWhitespace(cx, xml->xml_value);
             if (!str)
                 return NULL;
         } else {
             str = xml->xml_value;
         }
         return EscapeElementValue(cx, &sb, str);
 
       case JSXML_CLASS_ATTRIBUTE:
         /* Step 5. */
-        return EscapeAttributeValue(cx, &sb, xml->xml_value);
+        return EscapeAttributeValue(cx, &sb, xml->xml_value,
+                                   (indentLevel & TO_SOURCE_FLAG) != 0);
 
       case JSXML_CLASS_COMMENT:
         /* Step 6. */
         return MakeXMLCommentString(cx, &sb, xml->xml_value);
 
       case JSXML_CLASS_PROCESSING_INSTRUCTION:
         /* Step 7. */
         return MakeXMLPIString(cx, &sb, xml->name->localName, xml->xml_value);
@@ -2950,17 +2957,17 @@
                       (kid = XMLARRAY_MEMBER(&xml->xml_kids, 0, JSXML)) &&
                       kid->xml_class != JSXML_CLASS_TEXT);
 
         if (pretty && indentKids) {
             if (!GetUint32XMLSetting(cx, js_prettyIndent_str, &i))
                 goto out;
             nextIndentLevel = indentLevel + i;
         } else {
-            nextIndentLevel = 0;
+            nextIndentLevel = indentLevel & TO_SOURCE_FLAG;
         }
 
         XMLArrayCursorInit(&cursor, &xml->xml_kids);
         while ((kid = (JSXML *) XMLArrayCursorNext(&cursor)) != NULL) {
             if (pretty && indentKids)
                 js_AppendChar(&sb, '\n');
 
             kidstr = XMLToXMLString(cx, kid, &ancdecls, nextIndentLevel);
@@ -2970,17 +2977,17 @@
             js_AppendJSString(&sb, kidstr);
         }
         XMLArrayCursorFinish(&cursor);
         if (kid)
             goto out;
 
         if (pretty && indentKids) {
             js_AppendChar(&sb, '\n');
-            js_RepeatChar(&sb, ' ', indentLevel);
+            js_RepeatChar(&sb, ' ', indentLevel & ~TO_SOURCE_FLAG);
         }
         js_AppendCString(&sb, "</");
 
         /* Step 26. */
         if (ns->prefix && !IS_EMPTY(ns->prefix)) {
             js_AppendJSString(&sb, ns->prefix);
             js_AppendChar(&sb, ':');
         }
@@ -3003,17 +3010,17 @@
     XMLArrayFinish(cx, &decls);
     if (ancdecls.capacity != 0)
         XMLArrayFinish(cx, &ancdecls);
     return str;
 }
 
 /* ECMA-357 10.2 */
 static JSString *
-ToXMLString(JSContext *cx, jsval v)
+ToXMLString(JSContext *cx, jsval v, uint32 toSourceFlag)
 {
     JSObject *obj;
     JSString *str;
     JSXML *xml;
 
     if (JSVAL_IS_NULL(v) || JSVAL_IS_VOID(v)) {
         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
                              JSMSG_BAD_XML_CONVERSION,
@@ -3036,17 +3043,17 @@
         str = js_ValueToString(cx, v);
         if (!str)
             return NULL;
         return EscapeElementValue(cx, NULL, str);
     }
 
     /* Handle non-element cases in this switch, returning from each case. */
     xml = (JSXML *) JS_GetPrivate(cx, obj);
-    return XMLToXMLString(cx, xml, NULL, 0);
+    return XMLToXMLString(cx, xml, NULL, toSourceFlag | 0);
 }
 
 static JSXMLQName *
 ToAttributeName(JSContext *cx, jsval v)
 {
     JSString *name, *uri, *prefix;
     JSObject *obj;
     JSClass *clasp;
@@ -7115,17 +7122,17 @@
 
 /* XML and XMLList */
 static JSBool
 xml_toXMLString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                 jsval *rval)
 {
     JSString *str;
 
-    str = ToXMLString(cx, OBJECT_TO_JSVAL(obj));
+    str = ToXMLString(cx, OBJECT_TO_JSVAL(obj), 0);
     if (!str)
         return JS_FALSE;
     *rval = STRING_TO_JSVAL(str);
     return JS_TRUE;
 }
 
 /* XML and XMLList */
 static JSString *
@@ -7136,17 +7143,17 @@
     JSXMLArrayCursor cursor;
 
     if (xml->xml_class == JSXML_CLASS_ATTRIBUTE ||
         xml->xml_class == JSXML_CLASS_TEXT) {
         return xml->xml_value;
     }
 
     if (!HasSimpleContent(xml))
-        return ToXMLString(cx, OBJECT_TO_JSVAL(xml->object));
+        return ToXMLString(cx, OBJECT_TO_JSVAL(xml->object), 0); 
 
     str = cx->runtime->emptyString;
     JS_EnterLocalRootScope(cx);
     XMLArrayCursorInit(&cursor, &xml->xml_kids);
     while ((kid = (JSXML *) XMLArrayCursorNext(&cursor)) != NULL) {
         if (kid->xml_class != JSXML_CLASS_COMMENT &&
             kid->xml_class != JSXML_CLASS_PROCESSING_INSTRUCTION) {
             kidstr = xml_toString_helper(cx, kid);
@@ -7160,16 +7167,29 @@
         }
     }
     XMLArrayCursorFinish(&cursor);
     JS_LeaveLocalRootScope(cx);
     return str;
 }
 
 static JSBool
+xml_toSource(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
+             jsval *rval)
+{
+    JSString *str;
+
+    str = ToXMLString(cx, OBJECT_TO_JSVAL(obj), TO_SOURCE_FLAG);
+    if (!str)
+        return JS_FALSE;
+    *rval = STRING_TO_JSVAL(str);
+    return JS_TRUE;
+}
+
+static JSBool
 xml_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
              jsval *rval)
 {
     JSXML *xml;
     JSString *str;
 
     XML_METHOD_PROLOG;
     str = xml_toString_helper(cx, xml);
@@ -7219,19 +7239,19 @@
     {"propertyIsEnumerable",  xml_propertyIsEnumerable,  1,0,0},
     {"removeNamespace",       xml_removeNamespace,       1,0,0},
     {"replace",               xml_replace,               2,0,0},
     {"setChildren",           xml_setChildren,           1,0,0},
     {"setLocalName",          xml_setLocalName,          1,0,0},
     {"setName",               xml_setName,               1,0,0},
     {"setNamespace",          xml_setNamespace,          1,0,0},
     {js_text_str,             xml_text,                  0,0,0},
+    {js_toSource_str,         xml_toSource,              0,0,0},
     {js_toString_str,         xml_toString,              0,0,0},
     {js_toXMLString_str,      xml_toXMLString,           0,0,0},
-    {js_toSource_str,         xml_toXMLString,           0,0,0},
     {js_valueOf_str,          xml_valueOf,               0,0,0},
     {0,0,0,0,0}
 };
 
 static JSBool
 CopyXMLSettings(JSContext *cx, JSObject *from, JSObject *to)
 {
     int i;
@@ -7849,19 +7869,19 @@
     qn = ToAttributeName(cx, *vp);
     if (!qn)
         return JS_FALSE;
     *vp = OBJECT_TO_JSVAL(qn->object);
     return JS_TRUE;
 }
 
 JSString *
-js_EscapeAttributeValue(JSContext *cx, JSString *str)
+js_EscapeAttributeValue(JSContext *cx, JSString *str, JSBool quote)
 {
-    return EscapeAttributeValue(cx, NULL, str);
+    return EscapeAttributeValue(cx, NULL, str, quote);
 }
 
 JSString *
 js_AddAttributePart(JSContext *cx, JSBool isName, JSString *str, JSString *str2)
 {
     size_t len, len2, newlen;
     jschar *chars;
 
@@ -7908,17 +7928,17 @@
 js_EscapeElementValue(JSContext *cx, JSString *str)
 {
     return EscapeElementValue(cx, NULL, str);
 }
 
 JSString *
 js_ValueToXMLString(JSContext *cx, jsval v)
 {
-    return ToXMLString(cx, v);
+    return ToXMLString(cx, v, 0);
 }
 
 static JSBool
 anyname_toString(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,
                  jsval *rval)
 {
     *rval = ATOM_KEY(cx->runtime->atomState.starAtom);
     return JS_TRUE;
diff
--- mozilla.orig/js/src/jsxml.h
+++ mozilla/js/src/jsxml.h
@@ -266,17 +266,17 @@
  */
 extern JSBool
 js_IsXMLName(JSContext *cx, jsval v);
 
 extern JSBool
 js_ToAttributeName(JSContext *cx, jsval *vp);
 
 extern JSString *
-js_EscapeAttributeValue(JSContext *cx, JSString *str);
+js_EscapeAttributeValue(JSContext *cx, JSString *str, JSBool quote);
 
 extern JSString *
 js_AddAttributePart(JSContext *cx, JSBool isName, JSString *str,
                     JSString *str2);
 
 extern JSString *
 js_EscapeElementValue(JSContext *cx, JSString *str);
 
