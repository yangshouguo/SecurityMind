diff --git a/image/src/imgRequestProxy.h b/image/src/imgRequestProxy.h
--- a/image/src/imgRequestProxy.h
+++ b/image/src/imgRequestProxy.h
@@ -2,16 +2,17 @@
  *
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef imgRequestProxy_h__
 #define imgRequestProxy_h__
 
+#include "mozilla/WeakPtr.h"
 #include "imgIRequest.h"
 #include "nsISecurityInfoProvider.h"
 
 #include "nsILoadGroup.h"
 #include "nsISupportsPriority.h"
 #include "nsITimedChannel.h"
 #include "nsCOMPtr.h"
 #include "nsAutoPtr.h"
@@ -37,17 +38,18 @@ namespace mozilla {
 namespace image {
 class Image;
 } // namespace image
 } // namespace mozilla
 
 class imgRequestProxy : public imgIRequest,
                         public nsISupportsPriority,
                         public nsISecurityInfoProvider,
-                        public nsITimedChannel
+                        public nsITimedChannel,
+                        public mozilla::SupportsWeakPtr<imgRequestProxy>
 {
 public:
   NS_DECL_ISUPPORTS
   NS_DECL_IMGIREQUEST
   NS_DECL_NSIREQUEST
   NS_DECL_NSISUPPORTSPRIORITY
   NS_DECL_NSISECURITYINFOPROVIDER
   // nsITimedChannel declared below
diff --git a/image/src/imgStatusTracker.cpp b/image/src/imgStatusTracker.cpp
--- a/image/src/imgStatusTracker.cpp
+++ b/image/src/imgStatusTracker.cpp
@@ -12,16 +12,17 @@
 #include "Image.h"
 #include "ImageLogging.h"
 #include "nsIObserverService.h"
 
 #include "mozilla/Assertions.h"
 #include "mozilla/Services.h"
 
 using namespace mozilla::image;
+using mozilla::WeakPtr;
 
 class imgStatusTrackerNotifyingObserver : public imgDecoderObserver
 {
 public:
   imgStatusTrackerNotifyingObserver(imgStatusTracker* aTracker)
   : mTracker(aTracker) {}
 
   virtual ~imgStatusTrackerNotifyingObserver() {}
@@ -35,27 +36,33 @@ public:
   virtual void OnStartDecode()
   {
     LOG_SCOPE(GetImgLog(), "imgStatusTrackerNotifyingObserver::OnStartDecode");
     NS_ABORT_IF_FALSE(mTracker->GetImage(),
                       "OnStartDecode callback before we've created our image");
 
     mTracker->RecordStartDecode();
 
-    nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mTracker->mConsumers);
+    imgStatusTracker::ProxyArray::ForwardIterator iter(mTracker->mConsumers);
     while (iter.HasMore()) {
-      mTracker->SendStartDecode(iter.GetNext());
+      nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();
+      if (proxy) {
+        mTracker->SendStartDecode(proxy);
+      }
     }
 
     if (!mTracker->IsMultipart()) {
       mTracker->RecordBlockOnload();
 
-      nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mTracker->mConsumers);
+      imgStatusTracker::ProxyArray::ForwardIterator iter(mTracker->mConsumers);
       while (iter.HasMore()) {
-        mTracker->SendBlockOnload(iter.GetNext());
+        nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();
+        if (proxy) {
+          mTracker->SendBlockOnload(proxy);
+        }
       }
     }
   }
 
   virtual void OnStartRequest()
   {
     NS_NOTREACHED("imgStatusTrackerNotifyingObserver(imgDecoderObserver)::OnStartRequest");
   }
@@ -63,19 +70,22 @@ public:
   virtual void OnStartContainer()
   {
     LOG_SCOPE(GetImgLog(), "imgStatusTrackerNotifyingObserver::OnStartContainer");
 
     NS_ABORT_IF_FALSE(mTracker->GetImage(),
                       "OnStartContainer callback before we've created our image");
     mTracker->RecordStartContainer(mTracker->GetImage());
 
-    nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mTracker->mConsumers);
+    imgStatusTracker::ProxyArray::ForwardIterator iter(mTracker->mConsumers);
     while (iter.HasMore()) {
-      mTracker->SendStartContainer(iter.GetNext());
+      nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();
+      if (proxy) {
+        mTracker->SendStartContainer(proxy);
+      }
     }
   }
 
   virtual void OnStartFrame()
   {
     LOG_SCOPE(GetImgLog(), "imgStatusTrackerNotifyingObserver::OnStartFrame");
     NS_ABORT_IF_FALSE(mTracker->GetImage(),
                       "OnStartFrame callback before we've created our image");
@@ -89,51 +99,60 @@ public:
   virtual void FrameChanged(const nsIntRect* dirtyRect)
   {
     LOG_SCOPE(GetImgLog(), "imgStatusTrackerNotifyingObserver::FrameChanged");
     NS_ABORT_IF_FALSE(mTracker->GetImage(),
                       "FrameChanged callback before we've created our image");
 
     mTracker->RecordFrameChanged(dirtyRect);
 
-    nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mTracker->mConsumers);
+    imgStatusTracker::ProxyArray::ForwardIterator iter(mTracker->mConsumers);
     while (iter.HasMore()) {
-      mTracker->SendFrameChanged(iter.GetNext(), dirtyRect);
+      nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();
+      if (proxy) {
+        mTracker->SendFrameChanged(proxy, dirtyRect);
+      }
     }
   }
 
   virtual void OnStopFrame()
   {
     LOG_SCOPE(GetImgLog(), "imgStatusTrackerNotifyingObserver::OnStopFrame");
     NS_ABORT_IF_FALSE(mTracker->GetImage(),
                       "OnStopFrame callback before we've created our image");
 
     mTracker->RecordStopFrame();
 
-    nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mTracker->mConsumers);
+    imgStatusTracker::ProxyArray::ForwardIterator iter(mTracker->mConsumers);
     while (iter.HasMore()) {
-      mTracker->SendStopFrame(iter.GetNext());
+      nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();
+      if (proxy) {
+        mTracker->SendStopFrame(proxy);
+      }
     }
 
     mTracker->MaybeUnblockOnload();
   }
 
   virtual void OnStopDecode(nsresult aStatus)
   {
     LOG_SCOPE(GetImgLog(), "imgStatusTrackerNotifyingObserver::OnStopDecode");
     NS_ABORT_IF_FALSE(mTracker->GetImage(),
                       "OnStopDecode callback before we've created our image");
 
     bool preexistingError = mTracker->GetImageStatus() == imgIRequest::STATUS_ERROR;
 
     mTracker->RecordStopDecode(aStatus);
 
-    nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mTracker->mConsumers);
+    imgStatusTracker::ProxyArray::ForwardIterator iter(mTracker->mConsumers);
     while (iter.HasMore()) {
-      mTracker->SendStopDecode(iter.GetNext(), aStatus);
+      nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();
+      if (proxy) {
+        mTracker->SendStopDecode(proxy, aStatus);
+      }
     }
 
     // This is really hacky. We need to handle the case where we start decoding,
     // block onload, but then hit an error before we get to our first frame.
     mTracker->MaybeUnblockOnload();
 
     if (NS_FAILED(aStatus) && !preexistingError) {
       mTracker->FireFailureNotification();
@@ -147,43 +166,52 @@ public:
 
   virtual void OnDiscard()
   {
     NS_ABORT_IF_FALSE(mTracker->GetImage(),
                       "OnDiscard callback before we've created our image");
 
     mTracker->RecordDiscard();
 
-    nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mTracker->mConsumers);
+    imgStatusTracker::ProxyArray::ForwardIterator iter(mTracker->mConsumers);
     while (iter.HasMore()) {
-      mTracker->SendDiscard(iter.GetNext());
+      nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();
+      if (proxy) {
+        mTracker->SendDiscard(proxy);
+      }
     }
   }
 
   virtual void OnUnlockedDraw()
   {
     NS_ABORT_IF_FALSE(mTracker->GetImage(),
                       "OnUnlockedDraw callback before we've created our image");
     mTracker->RecordUnlockedDraw();
 
-    nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mTracker->mConsumers);
+    imgStatusTracker::ProxyArray::ForwardIterator iter(mTracker->mConsumers);
     while (iter.HasMore()) {
-      mTracker->SendUnlockedDraw(iter.GetNext());
+      nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();
+      if (proxy) {
+        mTracker->SendUnlockedDraw(proxy);
+      }
     }
   }
 
   virtual void OnImageIsAnimated()
   {
     NS_ABORT_IF_FALSE(mTracker->GetImage(),
                       "OnImageIsAnimated callback before we've created our image");
     mTracker->RecordImageIsAnimated();
 
-    nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mTracker->mConsumers);
+    imgStatusTracker::ProxyArray::ForwardIterator iter(mTracker->mConsumers);
     while (iter.HasMore()) {
-      mTracker->SendImageIsAnimated(iter.GetNext());
+      nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();
+      if (proxy) {
+        mTracker->SendImageIsAnimated(iter.GetNext());
+      }
     }
   }
 
   virtual void OnError()
   {
     mTracker->RecordError();
   }
 
@@ -455,27 +483,27 @@ imgStatusTracker::NotifyCurrentState(img
 
   // We don't keep track of
   nsCOMPtr<nsIRunnable> ev = new imgStatusNotifyRunnable(*this, proxy);
   NS_DispatchToCurrentThread(ev);
 }
 
 #define NOTIFY_IMAGE_OBSERVERS(func) \
   do { \
-    nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(proxies); \
+    ProxyArray::ForwardIterator iter(proxies); \
     while (iter.HasMore()) { \
-      nsRefPtr<imgRequestProxy> proxy = iter.GetNext(); \
-      if (!proxy->NotificationsDeferred()) { \
+      nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();  \
+      if (proxy && !proxy->NotificationsDeferred()) {          \
         proxy->func; \
       } \
     } \
   } while (false);
 
 /* static */ void
-imgStatusTracker::SyncNotifyState(nsTObserverArray<imgRequestProxy*>& proxies,
+imgStatusTracker::SyncNotifyState(ProxyArray& proxies,
                                   bool hasImage, uint32_t state,
                                   nsIntRect& dirtyRect, bool hadLastPart)
 {
   // OnStartRequest
   if (state & stateRequestStarted)
     NOTIFY_IMAGE_OBSERVERS(OnStartRequest());
 
   // OnStartContainer
@@ -601,23 +629,23 @@ imgStatusTracker::SyncNotifyDifference(c
 
   nsIntRect invalidRect = mInvalidRect.Union(diff.invalidRect);
 
   SyncNotifyState(mConsumers, !!mImage, diff.diffState, invalidRect, mHadLastPart);
 
   mInvalidRect.SetEmpty();
 
   if (diff.unblockedOnload) {
-    nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mConsumers);
+    ProxyArray::ForwardIterator iter(mConsumers);
     while (iter.HasMore()) {
       // Hold on to a reference to this proxy, since notifying the state can
       // cause it to disappear.
-      nsRefPtr<imgRequestProxy> proxy = iter.GetNext();
+      nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();
 
-      if (!proxy->NotificationsDeferred()) {
+      if (proxy && !proxy->NotificationsDeferred()) {
         SendUnblockOnload(proxy);
       }
     }
   }
 
   if (diff.foundError) {
     FireFailureNotification();
   }
@@ -643,18 +671,18 @@ imgStatusTracker::SyncNotify(imgRequestP
 
   nsIntRect r;
   if (mImage) {
     // XXX - Should only send partial rects here, but that needs to
     // wait until we fix up the observer interface
     r = mImage->FrameRect(imgIContainer::FRAME_CURRENT);
   }
 
-  nsTObserverArray<imgRequestProxy*> array;
-  array.AppendElement(proxy);
+  ProxyArray array;
+  array.AppendElement(proxy->asWeakPtr());
   SyncNotifyState(array, !!mImage, mState, r, mHadLastPart);
 }
 
 void
 imgStatusTracker::EmulateRequestFinished(imgRequestProxy* aProxy,
                                          nsresult aStatus)
 {
   nsCOMPtr<imgIRequest> kungFuDeathGrip(aProxy);
@@ -672,17 +700,17 @@ imgStatusTracker::EmulateRequestFinished
   if (!(mState & stateRequestStopped)) {
     aProxy->OnStopRequest(true);
   }
 }
 
 void
 imgStatusTracker::AddConsumer(imgRequestProxy* aConsumer)
 {
-  mConsumers.AppendElementUnlessExists(aConsumer);
+  mConsumers.AppendElementUnlessExists(aConsumer->asWeakPtr());
 }
 
 // XXX - The last argument should go away.
 bool
 imgStatusTracker::RemoveConsumer(imgRequestProxy* aConsumer, nsresult aStatus)
 {
   // Remove the proxy from the list.
   bool removed = mConsumers.RemoveElement(aConsumer);
@@ -699,16 +727,30 @@ imgStatusTracker::RemoveConsumer(imgRequ
   if (aConsumer->NotificationsDeferred() && runnable) {
     runnable->RemoveProxy(aConsumer);
     aConsumer->SetNotificationsDeferred(false);
   }
 
   return removed;
 }
 
+bool
+imgStatusTracker::FirstConsumerIs(imgRequestProxy* aConsumer)
+{
+  MOZ_ASSERT(NS_IsMainThread(), "Use mConsumers on main thread only");
+  ProxyArray::ForwardIterator iter(mConsumers);
+  while (iter.HasMore()) {
+    nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();
+    if (proxy) {
+      return proxy.get() == aConsumer;
+    }
+  }
+  return false;
+}
+
 void
 imgStatusTracker::RecordCancel()
 {
   if (!(mImageStatus & imgIRequest::STATUS_LOAD_PARTIAL))
     mImageStatus = imgIRequest::STATUS_ERROR;
 }
 
 void
@@ -862,19 +904,22 @@ imgStatusTracker::SendUnlockedDraw(imgRe
   if (!aProxy->NotificationsDeferred())
     aProxy->OnUnlockedDraw();
 }
 
 void
 imgStatusTracker::OnUnlockedDraw()
 {
   RecordUnlockedDraw();
-  nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mConsumers);
+  ProxyArray::ForwardIterator iter(mConsumers);
   while (iter.HasMore()) {
-    SendUnlockedDraw(iter.GetNext());
+    nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();
+    if (proxy) {
+      SendUnlockedDraw(proxy);
+    }
   }
 }
 
 void
 imgStatusTracker::RecordFrameChanged(const nsIntRect* aDirtyRect)
 {
   NS_ABORT_IF_FALSE(mImage,
                     "RecordFrameChanged called before we have an Image");
@@ -916,19 +961,22 @@ imgStatusTracker::SendStartRequest(imgRe
   if (!aProxy->NotificationsDeferred())
     aProxy->OnStartRequest();
 }
 
 void
 imgStatusTracker::OnStartRequest()
 {
   RecordStartRequest();
-  nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mConsumers);
+  ProxyArray::ForwardIterator iter(mConsumers);
   while (iter.HasMore()) {
-    SendStartRequest(iter.GetNext());
+    nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();
+    if (proxy) {
+      SendStartRequest(proxy);
+    }
   }
 }
 
 void
 imgStatusTracker::RecordStopRequest(bool aLastPart,
                                     nsresult aStatus)
 {
   mHadLastPart = aLastPart;
@@ -954,69 +1002,84 @@ imgStatusTracker::SendStopRequest(imgReq
 void
 imgStatusTracker::OnStopRequest(bool aLastPart,
                                 nsresult aStatus)
 {
   bool preexistingError = mImageStatus == imgIRequest::STATUS_ERROR;
 
   RecordStopRequest(aLastPart, aStatus);
   /* notify the kids */
-  nsTObserverArray<imgRequestProxy*>::ForwardIterator srIter(mConsumers);
+  ProxyArray::ForwardIterator srIter(mConsumers);
   while (srIter.HasMore()) {
-    SendStopRequest(srIter.GetNext(), aLastPart, aStatus);
+    nsRefPtr<imgRequestProxy> proxy = srIter.GetNext().get();
+    if (proxy) {
+      SendStopRequest(proxy, aLastPart, aStatus);
+    }
   }
 
   if (NS_FAILED(aStatus) && !preexistingError) {
     FireFailureNotification();
   }
 }
 
 void
 imgStatusTracker::OnDiscard()
 {
   RecordDiscard();
 
   /* notify the kids */
-  nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mConsumers);
+  ProxyArray::ForwardIterator iter(mConsumers);
   while (iter.HasMore()) {
-    SendDiscard(iter.GetNext());
+    nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();
+    if (proxy) {
+      SendDiscard(proxy);
+    }
   }
 }
 
 void
 imgStatusTracker::FrameChanged(const nsIntRect* aDirtyRect)
 {
   RecordFrameChanged(aDirtyRect);
 
   /* notify the kids */
-  nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mConsumers);
+  ProxyArray::ForwardIterator iter(mConsumers);
   while (iter.HasMore()) {
-    SendFrameChanged(iter.GetNext(), aDirtyRect);
+    nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();
+    if (proxy) {
+      SendFrameChanged(proxy, aDirtyRect);
+    }
   }
 }
 
 void
 imgStatusTracker::OnStopFrame()
 {
   RecordStopFrame();
 
   /* notify the kids */
-  nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mConsumers);
+  ProxyArray::ForwardIterator iter(mConsumers);
   while (iter.HasMore()) {
-    SendStopFrame(iter.GetNext());
+    nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();
+    if (proxy) {
+      SendStopFrame(proxy);
+    }
   }
 }
 
 void
 imgStatusTracker::OnDataAvailable()
 {
   // Notify any imgRequestProxys that are observing us that we have an Image.
-  nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mConsumers);
+  ProxyArray::ForwardIterator iter(mConsumers);
   while (iter.HasMore()) {
-    iter.GetNext()->SetHasImage();
+    nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();
+    if (proxy) {
+      proxy->SetHasImage();
+    }
   }
 }
 
 void
 imgStatusTracker::RecordBlockOnload()
 {
   MOZ_ASSERT(!(mState & stateBlockingOnload));
   mState |= stateBlockingOnload;
@@ -1048,19 +1111,22 @@ void
 imgStatusTracker::MaybeUnblockOnload()
 {
   if (!(mState & stateBlockingOnload)) {
     return;
   }
 
   RecordUnblockOnload();
 
-  nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mConsumers);
+  ProxyArray::ForwardIterator iter(mConsumers);
   while (iter.HasMore()) {
-    SendUnblockOnload(iter.GetNext());
+    nsRefPtr<imgRequestProxy> proxy = iter.GetNext().get();
+    if (proxy) {
+      SendUnblockOnload(proxy);
+    }
   }
 }
 
 void
 imgStatusTracker::RecordError()
 {
   mImageStatus = imgIRequest::STATUS_ERROR;
 }
diff --git a/image/src/imgStatusTracker.h b/image/src/imgStatusTracker.h
--- a/image/src/imgStatusTracker.h
+++ b/image/src/imgStatusTracker.h
@@ -4,27 +4,27 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef imgStatusTracker_h__
 #define imgStatusTracker_h__
 
 class imgDecoderObserver;
 class imgIContainer;
-class imgRequestProxy;
 class imgStatusNotifyRunnable;
 class imgRequestNotifyRunnable;
 class imgStatusTrackerObserver;
 class imgStatusTrackerNotifyingObserver;
 class nsIRunnable;
 
 #include "mozilla/RefPtr.h"
 #include "nsCOMPtr.h"
 #include "nsTObserverArray.h"
 #include "nsRect.h"
+#include "imgRequestProxy.h"
 
 namespace mozilla {
 namespace image {
 
 class Image;
 
 struct ImageStatusDiff
 {
@@ -153,19 +153,17 @@ public:
   // with its status. Weak pointers.
   void AddConsumer(imgRequestProxy* aConsumer);
   bool RemoveConsumer(imgRequestProxy* aConsumer, nsresult aStatus);
   size_t ConsumerCount() const { return mConsumers.Length(); }
 
   // This is intentionally non-general because its sole purpose is to support an
   // some obscure network priority logic in imgRequest. That stuff could probably
   // be improved, but it's too scary to mess with at the moment.
-  bool FirstConsumerIs(imgRequestProxy* aConsumer) {
-    return mConsumers.SafeElementAt(0, nullptr) == aConsumer;
-  }
+  bool FirstConsumerIs(imgRequestProxy* aConsumer);
 
   void AdoptConsumers(imgStatusTracker* aTracker) { mConsumers = aTracker->mConsumers; }
 
   // Returns whether we are in the process of loading; that is, whether we have
   // not received OnStopRequest.
   bool IsLoading() const;
 
   // Get the current image status (as in imgIRequest).
@@ -255,16 +253,17 @@ public:
   void ApplyDifference(const mozilla::image::ImageStatusDiff& aDiff);
 
   // Notify for the changes captured in an ImageStatusDiff. Because this may
   // result in recursive notifications, no decoding locks may be held.
   void SyncNotifyDifference(const mozilla::image::ImageStatusDiff& aDiff);
 
   nsIntRect GetInvalidRect() const { return mInvalidRect; }
 
+  typedef nsTObserverArray<mozilla::WeakPtr<imgRequestProxy>> ProxyArray;
 private:
   friend class imgStatusNotifyRunnable;
   friend class imgRequestNotifyRunnable;
   friend class imgStatusTrackerObserver;
   friend class imgStatusTrackerNotifyingObserver;
   imgStatusTracker(const imgStatusTracker& aOther);
 
   void FireFailureNotification();
