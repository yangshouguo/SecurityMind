diff --git a/content/base/src/nsObjectLoadingContent.cpp b/content/base/src/nsObjectLoadingContent.cpp
--- a/content/base/src/nsObjectLoadingContent.cpp
+++ b/content/base/src/nsObjectLoadingContent.cpp
@@ -1303,30 +1303,32 @@ nsObjectLoadingContent::LoadObject(nsIUR
   if (doc->IsBeingUsedAsImage()) {
     return NS_OK;
   }
 
   // From here on, we will always change the content. This means that a
   // possibly-loading channel should be aborted.
   if (mChannel) {
     LOG(("OBJLC [%p]: Cancelling existing load\n", this));
+    nsCOMPtr<nsIChannel> channel = mChannel;
+    mChannel = nsnull;
+    nsCOMPtr<nsIStreamListener> finalListener;
+    finalListener.swap(mFinalListener);
 
     // These three statements are carefully ordered:
     // - onStopRequest should get a channel whose status is the same as the
     //   status argument
     // - onStopRequest must get a non-null channel
-    mChannel->Cancel(NS_BINDING_ABORTED);
-    if (mFinalListener) {
+    channel->Cancel(NS_BINDING_ABORTED);
+    if (finalListener) {
       // NOTE: Since mFinalListener is only set in onStartRequest, which takes
       // care of calling mFinalListener->OnStartRequest, mFinalListener is only
       // non-null here if onStartRequest was already called.
-      mFinalListener->OnStopRequest(mChannel, nsnull, NS_BINDING_ABORTED);
-      mFinalListener = nsnull;
+      finalListener->OnStopRequest(channel, nsnull, NS_BINDING_ABORTED);
     }
-    mChannel = nsnull;
   }
 
   // Security checks
   if (doc->IsLoadedAsData()) {
     if (!doc->IsStaticDocument()) {
       Fallback(false);
     }
     return NS_OK;
